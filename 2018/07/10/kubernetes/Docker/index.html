<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="容器技术在 Linux 内核中，提供了 cgroups 功能，来达成资源的限制。它同时也提供了 namespaces 隔离的功能，使应用程序看到的操作系统环境被区隔成独立区间，包括进程树，网络，用户id，以及挂载的文件系统。 CgroupsCGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组  (process groups)  所使用的">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker知识总结">
<meta property="og:url" content="https://yangjinheng.github.io/2018/07/10/kubernetes/Docker/index.html">
<meta property="og:site_name" content="默默">
<meta property="og:description" content="容器技术在 Linux 内核中，提供了 cgroups 功能，来达成资源的限制。它同时也提供了 namespaces 隔离的功能，使应用程序看到的操作系统环境被区隔成独立区间，包括进程树，网络，用户id，以及挂载的文件系统。 CgroupsCGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组  (process groups)  所使用的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-02-25T09:22:07.445Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker知识总结">
<meta name="twitter:description" content="容器技术在 Linux 内核中，提供了 cgroups 功能，来达成资源的限制。它同时也提供了 namespaces 隔离的功能，使应用程序看到的操作系统环境被区隔成独立区间，包括进程树，网络，用户id，以及挂载的文件系统。 CgroupsCGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组  (process groups)  所使用的">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yangjinheng.github.io/2018/07/10/kubernetes/Docker/">





  <title>Docker知识总结 | 默默</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?be46574a10a6c2b7f67e9c32a008cbd5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">默默</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-前端知识">
          <a href="/categories/web/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-asterisk"></i> <br>
            
            前端知识
          </a>
        </li>
      
        
        <li class="menu-item menu-item-kubernetes">
          <a href="/categories/Kubernetes/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-cog"></i> <br>
            
            Kubernetes
          </a>
        </li>
      
        
        <li class="menu-item menu-item-运维笔记">
          <a href="/categories/运维笔记/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            运维笔记
          </a>
        </li>
      
        
        <li class="menu-item menu-item-python">
          <a href="/categories/Python/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-laptop"></i> <br>
            
            Python
          </a>
        </li>
      
        
        <li class="menu-item menu-item-golang">
          <a href="/categories/golang/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            Golang
          </a>
        </li>
      
        
        <li class="menu-item menu-item-个人日志">
          <a href="/categories/个人日志/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-github-alt"></i> <br>
            
            个人日志
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            给我留言
          </a>
        </li>
      

      
    </ul>
  

  
</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangjinheng.github.io/2018/07/10/kubernetes/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Heng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="默默">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Docker知识总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-10T00:00:00+08:00">
                2018-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h1><p>在 Linux 内核中，提供了 cgroups 功能，来达成资源的限制。它同时也提供了 namespaces 隔离的功能，使应用程序看到的操作系统环境被区隔成独立区间，包括进程树，网络，用户id，以及挂载的文件系统。</p>
<h2 id="Cgroups"><a href="#Cgroups" class="headerlink" title="Cgroups"></a>Cgroups</h2><p>CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组  (process groups)  所使用的物理资源  (如 cpu memory i/o 等等)  的机制，简单来将就是把进程放到一个组里面统一加以控制。CGroup 2007 年进入 Linux 2.6.24 内核，CGroups 不是全新创造的，它将进程管理从 cpuset 中剥离出来，作者是 Google 的 Paul Menage。</p>
<p>CGroups 也是 LXC 为实现虚拟化所使用的资源管理手段，Cgroup 有个重要概念叫子系统，子系统也就是资源控制器，每个子系统就是一个资源分配器，比如 CPU 子系统是控制CPU时间分配的，首先挂载子系统，然后才有 Control Group 的。比如，先挂载 memory 子系统，然后在 memory 子系统中创建一个 Cgroup 子节点，在这个节点中，将需要控制的进程 ID 写入，并且将控制的属性写入，这样就完成了内存的限制。</p>
<ul>
<li>子系统</li>
</ul>
<table>
<thead>
<tr>
<th>子系统</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>blkio</code></td>
<td>为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）</td>
</tr>
<tr>
<td><code>cpu</code></td>
<td>使用调度程序提供对 CPU 的 cgroup 任务访问</td>
</tr>
<tr>
<td><code>cpuacct</code></td>
<td>自动生成 cgroup 中任务所使用的 CPU 报告</td>
</tr>
<tr>
<td><code>cpuset</code></td>
<td>为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点</td>
</tr>
<tr>
<td><code>freezer</code></td>
<td>可允许或者拒绝 cgroup 中的任务访问设备</td>
</tr>
<tr>
<td><code>freezer</code></td>
<td>设定 cgroup 中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告</td>
</tr>
<tr>
<td><code>memory</code></td>
<td>挂起或者恢复 cgroup 中的任务</td>
</tr>
<tr>
<td><code>net_cls</code></td>
<td>使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包</td>
</tr>
</tbody>
</table>
<h2 id="Namespaces"><a href="#Namespaces" class="headerlink" title="Namespaces"></a>Namespaces</h2><p>Linux Namespaces 机制提供一种资源隔离方案。PID, IPC, Network 等系统资源不再是全局性的 (在Linux2.6内核以前是全局的)，而是属于特定的Namespace。每个 Namespace 里面的资源对其他 Namespace 都是透明的。namespace 是容器中使用到的重要技术之一，是对系统资源的操作上的隔离，使不同的容器间互不干扰。</p>
<p>Linux Namespaces 机制本身就是为了实现“基于容器的虚拟化”开发的。它提供了一套轻量级、高效率的系统资源隔离方案，远比传统的虚拟化技术开销小，不过它也不是完美的，它为内核的开发带来了更多的复杂性，它在隔离性和容错性上跟传统的虚拟化技术比也还有差距。</p>
<ul>
<li>名称空间</li>
</ul>
<table>
<thead>
<tr>
<th>名称空间</th>
<th>系统调用</th>
<th>说明</th>
<th>内核版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>主机名和域名</td>
<td>2.6.19</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>信号量、消息队列、共享内存等进程间通信</td>
<td>2.6.19</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>进程编号</td>
<td>2.6.24</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>网络设备、网络栈、端口</td>
<td>2.6.29</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>挂载点（文件系统）</td>
<td>2.4.19</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>用户和组</td>
<td>3.8</td>
</tr>
</tbody>
</table>
<h2 id="LXC"><a href="#LXC" class="headerlink" title="LXC"></a>LXC</h2><p>LXC（Linux Container）它为Linux内核中容器功能（cgroups与namespaces等组件）提供一个用户空间接口，这个容器可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性（虚拟化层）。容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。本身极为轻量化，提升了创建虚拟机的速度，LXC 的定位是替代传统的虚拟机，侧重于提供一个个操作系统，如 Ubuntu、Debian等。</p>
<p>LXC 建立在 CGroup 基础上，我们可以粗略的认为 LXC = Cgroup+ namespace + Chroot + veth +用户态控制脚本。LXC 利用内核的新特性 (CGroup) 来提供用户空间的对象，用来保证资源的隔离和对于应用或者系统的资源控制。</p>
<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>Docker 是 dotCloud 也就是现在的 Docker 公司在2013年3月发布的，一开始是基于 LXC 项目来创建单个应用程序容器，Docker 最新版现在已经开发了 libcontainer 容器管理包，直接使用内核的 namespaces 和cgroup，在Docker中 (LXC、libcontainer、runC) 负责资源管理，AUFS负责镜像管理，后被 Overlayfs 代替。</p>
<p>最早的时候 Docker 就是一个开源项目，主要由 Docker 公司维护，2017年年初，Docker 公司将原先的 Docker 项目改名为 Moby，Moby 后由社区维护的的开源项目，Docker 官方则又将 Docker 分为两个版本：Docker CE 一个基于 Moby 版本的分支，由 Docker 公司维护，Docker EE 则闭源，为商业提供支持。</p>
<p>LXC 是面向操作系统级别的轻量级虚拟化，而 Docker 是面向应用的，官方提倡一个容器即是一个应用，以应用为中心，Docker 软件用来管理 LXC 的环境。</p>
<h2 id="runC"><a href="#runC" class="headerlink" title="runC"></a>runC</h2><p>OCI组织由Linux基金会和Docker成立，旨在围绕容器格式和运行时制定一个开放的工业化标准，OCI 这个组织提出了 OCF（开放容器格式标准），runC 是Docker按照开放容器格式标准（OCF, Open Container Format）制定的一种具体实现，runC 的前身实际上是 Docker 的 libcontainer 项目演化而来。</p>
<h2 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h2><p>UnionFS是一种为Linux，FreeBSD和NetBSD操作系统设计的把其他文件系统联合到一个联合挂载点的文件系统服务。它使用branch把不同文件系统的文件和目录“透明地”覆盖，形成一个单一一致的文件系统。这些 branches 或者是 read-only 或者是 read-write 的，所以当对这个虚拟后的联合文件系统进行写操作的时候，系统是真正写到了一个新的文件中。看起来这个虚拟后的联合文件系统是可以对任何文件进行操作的，但是其实它并没有改变原来的文件，这是因为 unionfs 用到了一个重要的资管管理技术叫写时复制。</p>
<p>写时复制（copy-on-write，下文简称CoW），也叫隐式共享，是一种对可修改资源实现高效复制的资源管理技术。它的思想是，如果一个资源是重复的，但没有任何修改，这时候并不需要立即创建一个新的资源；这个资源可以被新旧实例共享。创建新资源发生在第一次写操作，也就是对资源进行修改的时候。通过这种资源共享的方式，可以显著地减少未修改资源复制带来的消耗，但是也会在进行资源修改的时候增减小部分的开销。</p>
<ul>
<li>AUFS</li>
</ul>
<p>AUFS 是一种 UnionFS，是 Junjiro Okajima（岡島順治郎）在2006年开发的，AUFS 完全重写了早期的 UnionFS 1.x，其主要目的是为了可靠性和性能，并且引入了一些新的功能，比如可写分支的负载均衡。AUFS在使用上全兼容 UnionFS，而且比之前的 UnionFS 在稳定性和性能上都要好很多，后来的 UnionFS 2.x 开始抄AUFS中的功能。但是它一直没有整合进入 Linux 内核，就是因为 Linus 不让，基本上是因为代码量比较多，而且写得烂，岡島不断地改进代码质量，不断地提交，不断地被Linus 拒掉，在新版的 Docker 中 AUFS 已经被 Overlayfs 代替。</p>
<ul>
<li>Overlayfs</li>
</ul>
<p>Overlayfs是一种 UnionFS，Linux内核3.18后整合了Overlayfs，和 AUFS 的多层不同的是 Overlay 只有两层：一个 upper 文件系统和一个 lower 文件系统，分别代表Docker的镜像层和容器层。当需要修改一个文件时，使用 CoW 将文件从只读的 lower 复制到可写的 upper 进行修改，结果也保存在 upper 层。在 Docker 中，底下的只读层就是 image，可写层就是 Container，当写入一个新文件时，为在容器的快照里为其分配一个新的数据块，文件写在这个空间里，这个叫用时分配。而当要修改已有文件时，使用 CoW 复制分配一个新的原始数据和快照，在这个新分配的空间变更数据，变结束再更新相关的数据结构指向新子文件系统和快照，原来的原始数据和快照没有指针指向，被覆盖，在新版的 Docker 中 AUFS 已经被 Overlayfs 代替。</p>
<h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><p>Registry 用于保存 Docker 镜像，包括镜像的层次结构和数据，Registry 由 Registry 和 index 组成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Registry ：一个 Docker 镜像的所有版本组成的仓库叫一个 Registry，每个仓库可以有多个标签，每个标签对应一个镜像。</span><br><span class="line">一个 Registry 中可以存在多个 Registry ，划分为顶层仓库和用户仓库，用户仓库的格式为：用户名/仓库名</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Index：维护用户账户，镜像的校验及公共命名空间信息，它相当于为 Registry 提供了一个完成用户认证等功能的检索接口</span><br></pre></td></tr></table></figure>
<ul>
<li>用户可自建 Registry ，也可以使用官方的 Docker HUB，Registry 有以下分类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sponsor Registry ：第三方的 Registry ，供客户和 Docker 社区使用</span><br><span class="line">Mirror Registry ：第三方的 Registry ，只让客户使用，如：Docker中国、阿里云</span><br><span class="line">Vendor Registry ：由发布 Docker 镜像的供应商提供的 Registry 如：红帽的 Registry</span><br><span class="line">Private Registry ：私有实体提供的 Registry ，如：自建 Registry 私有的</span><br></pre></td></tr></table></figure>
<ul>
<li>仓库和镜像的组织形式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Docker 仓库名就是一个镜像主名字，一个镜像使用标签来标记来标记不同的版本，所以仓库名 + 标签名才能唯一标识一个镜像，如果在拉取镜像的时候只给了仓库的名字，则默认拉取这个仓库的最新版本镜像，例如：</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx                             # 仓库的名字</span><br><span class="line">  - nginx:1.15 nginx:latest       # 标签可以有多个</span><br><span class="line">  - nginx:1.14 nginx:stble        # 不同标签标记不同版本</span><br><span class="line">  - nginx:1.10                    # 仓库 + 标签能够唯一标识镜像</span><br></pre></td></tr></table></figure>
<ul>
<li>查看所有可用标签</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://hub.docker.com/r/library/nginx/tags/</span><br></pre></td></tr></table></figure>
<ul>
<li>Docker HUB</li>
</ul>
<p>一种是Docker官方提供的 Registry，称为Docker Hub，它和Github一样，我们可以注册账号，并存储自己的镜像，也可以使用别人的镜像，由于 Docker HUB 仓库在国内受到 GFW 的限制，速度极慢，所以互联网上有一些非官方的加速器。</p>
<ul>
<li>国内加速器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://cr.console.aliyun.com/cn-hangzhou/mirrors  # 阿里云镜像加速</span><br><span class="line">http://www.docker-cn.com/registry-mirror           # Docker 中国官方镜像加速</span><br><span class="line">https://docker.mirrors.ustc.edu.cn/                # 中科大镜像加速器</span><br></pre></td></tr></table></figure>
<h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><h2 id="Base镜像"><a href="#Base镜像" class="headerlink" title="Base镜像"></a>Base镜像</h2><p>BASE 镜像简单来说就是不依赖其他任何镜像，完全从 0 开始建起，其他镜像都是建立在他的之上，可以比喻为大楼的地基，BASE 镜像有两层含义：</p>
<ol>
<li>不依赖其他镜像，从 scratch （官方制作的特殊空镜像）镜像构建</li>
<li>任何镜像都可以作为基础镜像被再次增加新的内容</li>
</ol>
<p>所以，能称作 BASE 镜像的通常都是各种 Linux 发行版的 Docker 镜像，比如 Ubuntu, Debian, CentOS 等。 </p>
<h2 id="镜像组成"><a href="#镜像组成" class="headerlink" title="镜像组成"></a>镜像组成</h2><ul>
<li>Linux系统文件系统组成</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. bootfs (引导文件系统)，包含： bootloader 和 kernel，bootloader 作用是加载 kernel 到内存运行，完成后 bootfs 就从内存卸载。</span><br><span class="line">2. rootfs (根文件系统)，即：bin,etc,lib,mnt,root,sbin,sys,usr,dev,home,media,proc,run,srv,tmp,var，这些目录组成。</span><br></pre></td></tr></table></figure>
<ul>
<li>Docker镜像的文件组成</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. bootf (引导文件系统)，Docker 镜像使用系统 kernel ，无论什么发行版的 Docker 镜像都直接使用（且只能使用）宿主机的 kernel 且不能修改。</span><br><span class="line">2. rootfs (根文件系统)，Docker 不同发行版镜像都只需提供 rootfs ，镜像是只读的无法写入，Docker 镜像是建立在 UnionFS 这种文件系统之上。</span><br></pre></td></tr></table></figure>
<h2 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2><ul>
<li>镜像的分层结构</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Docker 支持通过扩展现有镜像，创建新的镜像，实际上，Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的，比如：Nginx 的 base 层是 Alpine Linux 再加上 Nginx 组成，多个镜像共享一个 base 层，这很大程度节约磁盘空间。</span><br><span class="line"></span><br><span class="line">由于 Docker 镜像是只读的，Docker 容器在启动后会按顺序加载每一层，最后加载一个可读写的层，所以容器启动后的一切操作都相当于在新层进行读写，所以基于同一个 base 镜像的镜像是不会互相干扰的。</span><br></pre></td></tr></table></figure>
<h2 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h2><ul>
<li>Docker镜像的加载过程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.  Linux 启动时，会首先将 rootfs 置为 readonly, 进行一系列检查, 然后将其切换为 readwrite 供用户使用，用户直接对 rootfs 读写。</span><br><span class="line">2.  在 Docker 中，起初也是将 rootfs 以 readonly 方式加载并检查，之后并不会把 rootfs 的 read-only 改为 read-write，而是用 UnionFS 的 union mount 机制将一个或 read-only 的 rootfs 加载到之前的 read-only 的 rootfs 层之上，在加载了这么多层的 rootfs 之后，仍然让它看起来只像是一个文件系统，在 Docker 的体系里把 union mount 的这些 read-only 的 rootfs 叫做Docker的镜像，但是此时的每一层 rootfs 都是 read-only 的，我们此时还不能对其进行操作。当我们创建一个容器，也就是将 Docker 镜像进行实例化，系统会在一层或是多层 read-only 的 rootfs 之上分配一层空的read-write 的 rootfs。</span><br></pre></td></tr></table></figure>
<h2 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h2><ul>
<li>联合文件系统与写时复制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">镜像层数可能会很多，所有镜像层会联合在一起组成一个统一的文件系统，如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。</span><br><span class="line"></span><br><span class="line">1. 添加文件：在容器中创建文件时，新文件被添加到容器层中。</span><br><span class="line">2. 读取文件：在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存。</span><br><span class="line">3. 修改文件：在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</span><br><span class="line">4. 删除文件：在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</span><br><span class="line"></span><br><span class="line">只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  参考：<a href="http://blog.51cto.com/wzlinux/category16.html" target="_blank" rel="noopener">http://blog.51cto.com/wzlinux/category16.html</a></p>
</blockquote>
<h1 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h1><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><ul>
<li>Docker Server</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Docker daemon 的主要组成部分，默认只监听在本机的 Unix Sock 文件，还可以使用 IPV4 Sock，接受客户端的连接。</span><br></pre></td></tr></table></figure>
<ul>
<li>Docker Client</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Docker的客户端，默认连接本机</span><br></pre></td></tr></table></figure>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><ul>
<li>检查内核版本，Docker 要求 CentOS 系统的内核版本高于 3.10，并且 extras 的 YUM 仓库必须启用。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># uname -r</span></span><br><span class="line">3.10.0-862.9.1.el7.x86_64</span><br></pre></td></tr></table></figure>
<ul>
<li>设置 Docker 源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<ul>
<li>安装 Docker 并启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce</span><br></pre></td></tr></table></figure>
<ul>
<li>启动 Docker 并查看 Docker 版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl start docker</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>
<ul>
<li>vim /etc/docker/daemon.json，配置配置加速器 Azure</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"http://f1361db2.m.daocloud.io"</span></span><br><span class="line"><span class="string">"https://dockerhub.azk8s.cn"</span></span><br><span class="line"><span class="string">"https://reg-mirror.qiniu.com"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">cat &gt;/etc/docker/daemon.json&lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://dockerhub.azk8s.cn"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<ul>
<li>Docker 日志文件，默认会打印在系统日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tailf /var/log/messages | grep docker</span><br></pre></td></tr></table></figure>
<ul>
<li>查看服务器实时事件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker events</span><br></pre></td></tr></table></figure>
<h2 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h2><ul>
<li>搜索镜像，和搜索结果的字段含义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th><code>NAME</code></th>
<th><code>DESCRIPTION</code></th>
<th><code>STARS</code></th>
<th><code>OFFICIAL</code></th>
<th><code>AUTOMATED</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>镜像名称</td>
<td>镜像描述</td>
<td>星级</td>
<td>是否为官方</td>
<td>是否自动创建</td>
</tr>
</tbody>
</table>
<ul>
<li>拉取镜像指令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image pull nginx                            <span class="comment"># 直接下载最新版本</span></span><br><span class="line">docker image pull nginx:stable-alpine              <span class="comment"># 指定标签下载</span></span><br><span class="line">docker pull quay.io/coreos/flannel:v0.10.0-amd64   <span class="comment"># 指定第三方仓库和标签下载</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看本地镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image ls                          <span class="comment"># 查看本地镜像</span></span><br><span class="line">docker image ls --no-trunc               <span class="comment"># 查看本地镜像完整信息</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除一个镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image rm nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>为镜像打新的标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image tag e1ddd7948a1c jinheng/httpd:latest        <span class="comment"># 为 e1ddd7948a1c 镜像打一个新的标签</span></span><br></pre></td></tr></table></figure>
<ul>
<li>查看镜像的详细信息，JSON 数组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image inspect busybox:latest</span><br></pre></td></tr></table></figure>
<ul>
<li>查看镜像的历史版本信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">history</span> busybox:latest</span><br></pre></td></tr></table></figure>
<ul>
<li>删除 \&lt;none> 的镜像 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop $(docker ps -a | grep <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1 &#125;'</span>)    <span class="comment"># 停止处于退出状态的容器</span></span><br><span class="line">docker rm $(docker ps -a | grep <span class="string">"Exited"</span> | awk <span class="string">'&#123;print $1 &#125;'</span>)      <span class="comment"># 删除容器</span></span><br><span class="line">docker rmi $(docker images | grep <span class="string">"none"</span> | awk <span class="string">'&#123;print $3&#125;'</span>)       <span class="comment"># 删除镜像</span></span><br></pre></td></tr></table></figure>
<h2 id="启动一个容器"><a href="#启动一个容器" class="headerlink" title="启动一个容器"></a>启动一个容器</h2><ul>
<li>创建并启动一个容器，如果镜像在本地不存在，则自动联网下载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">OPTIONS              <span class="comment"># 容器启动选项</span></span><br><span class="line">    -t, --tty            <span class="comment"># 打开一个终端，提供交互式访问</span></span><br><span class="line">    -i, --interactive    <span class="comment"># 保持交互式访问</span></span><br><span class="line">    -d, --detach         <span class="comment"># 在后台运行容器</span></span><br><span class="line">    --name string        <span class="comment"># 为容器指定一个名称</span></span><br><span class="line">    --rm                 <span class="comment"># 容器停止时自动删除容器</span></span><br><span class="line">IMAGE                <span class="comment"># 容器使用的镜像，本地没有的镜像会自动联网下载</span></span><br><span class="line">COMMAND              <span class="comment"># 启动后运行的命令，缺省为容器内部默认命令</span></span><br><span class="line">ARG                  <span class="comment"># 启动后运行命令的参数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启动一个容器，运行容器内默认的程序，-it 打开默认的交互式终端，–rm 退出容器后自动删除容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run --name b1 -it --rm busybox                  <span class="comment"># 没有指定运行程序，-it 则会默认打开交互式终端程序 /bin/sh</span></span><br><span class="line">docker container run --name b1 -it --rm busybox top              <span class="comment"># 运行自定义程序，当程序退出，容器就会结束</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启动一个容器，会执行容器默认的命令，-d 在后台执行（与 -it 不能同时使用）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run --name b2 --rm -d nginx                     <span class="comment"># 默认程序为 nginx 会运行为守护进程，它会一直在后台运行</span></span><br><span class="line">docker container run --name b2 --rm -d busybox sleep 10          <span class="comment"># 当运行的 sleep 进程结束，容器就会退出</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个容器，但不启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container create --name b2 nginx        <span class="comment"># 创建一个容器，不运行</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启动停止删除容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container start                         <span class="comment"># 启动一个容器</span></span><br><span class="line">docker container stop                          <span class="comment"># 停止一个容器</span></span><br><span class="line">docker container <span class="built_in">kill</span>                          <span class="comment"># 强制停止一个容器</span></span><br><span class="line">docker container pause                         <span class="comment"># 暂停一个容器</span></span><br><span class="line">docker container unpause                       <span class="comment"># 取消暂停一个容器</span></span><br><span class="line">docker container rm                            <span class="comment"># 删除一个容器</span></span><br></pre></td></tr></table></figure>
<h2 id="连入运行中的容器"><a href="#连入运行中的容器" class="headerlink" title="连入运行中的容器"></a>连入运行中的容器</h2><ul>
<li>在容器中运行额外的命令，-it 终端交互，在容器中运行额外的指令，退出不会停止容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run --name b2 --rm -d nginx    <span class="comment"># 启动一个容器，运行默认的进程</span></span><br><span class="line">docker container <span class="built_in">exec</span> -it b2 /bin/sh            <span class="comment"># 连接到已经启动的容器，额外运行一个交互式终端</span></span><br></pre></td></tr></table></figure>
<ul>
<li>附加到当前容器的 <code>standard input, output</code> 也就是附加到主进程，注意从容器退出容器将终止（使用 –sig-proxy=false 不将退出信号代理给容器进程，退出也不会结束容器）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run --name b2 --rm -d nginx    <span class="comment"># 启动一个容器，运行默认的进程</span></span><br><span class="line">docker container attach b2                      <span class="comment"># 附加到已经启动的容器主进程，注意从这个进程中退出（键盘中断），容器就会退出</span></span><br><span class="line">docker container attach --sig-proxy=<span class="literal">false</span> b2    <span class="comment"># 附加到已经启动的容器主进程，但是收到的信号不会代理给容器内部的进程，而是被 attach 本身接收，退出不会结束容器</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启动处于停止状态的容器，-a attach 附加到容器的主进程，-i 打开交互式终端，注意从容器退出容器将终止</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container create --name b2 --rm nginx    <span class="comment"># 创建一个容器但不启动</span></span><br><span class="line">docker container start -i -a b2                 <span class="comment"># 启动容器，打开一个交互式终端并将终端附加到容器的标准输入、标准输出</span></span><br></pre></td></tr></table></figure>
<h2 id="容器状态查看"><a href="#容器状态查看" class="headerlink" title="容器状态查看"></a>容器状态查看</h2><ul>
<li>列出正在运行的容器，和列出结果的字段含义</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container ls                      <span class="comment"># 列出正在运行的容器</span></span><br><span class="line">docker container ls -a                   <span class="comment"># 列出包括停止的所有容器</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>CONTAINER ID</th>
<th>IMAGE</th>
<th>COMMAND</th>
<th>CREATED</th>
<th>STATUS</th>
<th>PORTS</th>
<th>NAMES</th>
</tr>
</thead>
<tbody>
<tr>
<td>容器ID</td>
<td>镜像</td>
<td>运行的程序</td>
<td>创建时间</td>
<td>当前状态</td>
<td>映射端口</td>
<td>容器名字</td>
</tr>
</tbody>
</table>
<ul>
<li>查看一个容器的详细信息，使用 go 模板语言可以提取单项信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container inspect web1</span><br></pre></td></tr></table></figure>
<ul>
<li>查看容器运行的进程号</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format <span class="string">"&#123;&#123;.State.Pid&#125;&#125;"</span> &lt;CONTAINER ID or NAME&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看容器的IP地址信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect --format <span class="string">'&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;'</span> &lt;CONTAINER ID or NAME&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看容器内部运行的进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker top &lt;CONTAINER ID or NAME&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>查看一个容器的日志</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container logs web1</span><br></pre></td></tr></table></figure>
<h2 id="推送镜像到仓库"><a href="#推送镜像到仓库" class="headerlink" title="推送镜像到仓库"></a>推送镜像到仓库</h2><ul>
<li>登陆到 Registry</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -u, --username string   # Username</span><br><span class="line">  -p, --password string   # Password</span><br><span class="line">      --password-stdin    # 从标准输入获取密码</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login -u yangjinheng -p 123456                                            <span class="comment"># 默认登陆 Docker HUB</span></span><br><span class="line">docker login --username=user registry.cn-hangzhou.aliyuncs.com                   <span class="comment"># 登陆到阿里云</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为本地镜像打标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image tag 11426a19f1a2 momokanshijie/httpd                                <span class="comment"># 准备推送到 Docker HUB</span></span><br><span class="line">docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/yangjinheng/<span class="built_in">test</span>:[tag]    <span class="comment"># 准备推送到阿里云</span></span><br></pre></td></tr></table></figure>
<ul>
<li>推送镜像，注意镜像的名称一定要和 Registry 相同</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image push [OPTIONS] NAME[:TAG]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image push momokanshijie/httpd                                            <span class="comment"># 推送到 Docker HUB</span></span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/yangjinheng/<span class="built_in">test</span>:[tag]             <span class="comment"># 推送到阿里云</span></span><br></pre></td></tr></table></figure>
<ul>
<li>拉取镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image pull registry.cn-hangzhou.aliyuncs.com/yangjinheng/<span class="built_in">test</span>:[tag]       <span class="comment"># 从阿里云拉取</span></span><br></pre></td></tr></table></figure>
<h2 id="基于容器制作镜像"><a href="#基于容器制作镜像" class="headerlink" title="基于容器制作镜像"></a>基于容器制作镜像</h2><ul>
<li>首先运行一个镜像，在容器内部做出需要的修改，最后使用 commit 基于容器来制作一个新的镜像，例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name centos -it centos /bin/bash</span><br></pre></td></tr></table></figure>
<ul>
<li>提交对容器的修改到新的镜像，-c 来修改镜像的 Docker 指令（列表格式）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container commit -a <span class="string">"yangjinheng"</span> centos yangjinheng_centos</span><br><span class="line">docker container commit -a <span class="string">"yangjinheng"</span> -c <span class="string">"CMD ['/bin/httpd','-f','-h','/data/html']"</span> -p centos yangjinheng_centos</span><br></pre></td></tr></table></figure>
<ul>
<li>基于已有的容器制作镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line">    </span><br><span class="line">OPTIONS：                      # 提交选项</span><br><span class="line">    -a, --author string        # 作者信息</span><br><span class="line">    -c, --change list          # 修改 Docker 镜像的一些指令定义。就是 inspect 信息</span><br><span class="line">    -m, --message string       # 提交信息</span><br><span class="line">    -p, --pause                # 提交时暂停容器运行</span><br><span class="line">CONTAINER：                    # 容器名称</span><br><span class="line">REPOSITORY[:TAG]               # 仓库名称 + 标签</span><br></pre></td></tr></table></figure>
<h2 id="镜像导入导出"><a href="#镜像导入导出" class="headerlink" title="镜像导入导出"></a>镜像导入导出</h2><ul>
<li>导出镜像到文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">OPTIONS：</span><br><span class="line">    -o, --output string        <span class="comment"># 保存到指定的文件名中</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image save -o /tmp/centos6.9.tar.gz centos    <span class="comment"># 导出 centos 镜像到 /tmp/centos6.9.tar.gz 文件中</span></span><br></pre></td></tr></table></figure>
<ul>
<li>从文件导入镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image load [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -i, --input string          <span class="comment"># 从归档文件中读取</span></span><br><span class="line">  -q, --quiet                 <span class="comment"># 安静模式</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image load -i /tmp/centos6.9.tar.gz           <span class="comment"># 导入 /tmp/centos6.9.tar.gz</span></span><br></pre></td></tr></table></figure>
<h2 id="命令大全"><a href="#命令大全" class="headerlink" title="命令大全"></a>命令大全</h2><ul>
<li>daemon.json，可用全部参数</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"authorization-plugins"</span>: [],</span><br><span class="line">	<span class="attr">"data-root"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"dns"</span>: [],</span><br><span class="line">	<span class="attr">"dns-opts"</span>: [],</span><br><span class="line">	<span class="attr">"dns-search"</span>: [],</span><br><span class="line">	<span class="attr">"exec-opts"</span>: [],</span><br><span class="line">	<span class="attr">"exec-root"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"experimental"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"storage-driver"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"storage-opts"</span>: [],</span><br><span class="line">	<span class="attr">"labels"</span>: [],</span><br><span class="line">	<span class="attr">"live-restore"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">"log-driver"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"log-opts"</span>: &#123;&#125;,</span><br><span class="line">	<span class="attr">"mtu"</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">"pidfile"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"cluster-store"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"cluster-store-opts"</span>: &#123;&#125;,</span><br><span class="line">	<span class="attr">"cluster-advertise"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"max-concurrent-downloads"</span>: <span class="number">3</span>,</span><br><span class="line">	<span class="attr">"max-concurrent-uploads"</span>: <span class="number">5</span>,</span><br><span class="line">	<span class="attr">"default-shm-size"</span>: <span class="string">"64M"</span>,</span><br><span class="line">	<span class="attr">"shutdown-timeout"</span>: <span class="number">15</span>,</span><br><span class="line">	<span class="attr">"debug"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">"hosts"</span>: [],</span><br><span class="line">	<span class="attr">"log-level"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"tls"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">"tlsverify"</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">"tlscacert"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"tlscert"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"tlskey"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"swarm-default-advertise-addr"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"api-cors-header"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"selinux-enabled"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"userns-remap"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"group"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"cgroup-parent"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"default-ulimits"</span>: &#123;&#125;,</span><br><span class="line">	<span class="attr">"init"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"init-path"</span>: <span class="string">"/usr/libexec/docker-init"</span>,</span><br><span class="line">	<span class="attr">"ipv6"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"iptables"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"ip-forward"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"ip-masq"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"userland-proxy"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"userland-proxy-path"</span>: <span class="string">"/usr/libexec/docker-proxy"</span>,</span><br><span class="line">	<span class="attr">"ip"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">	<span class="attr">"bridge"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"bip"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"fixed-cidr"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"fixed-cidr-v6"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"default-gateway"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"default-gateway-v6"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"icc"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"raw-logs"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"allow-nondistributable-artifacts"</span>: [],</span><br><span class="line">	<span class="attr">"registry-mirrors"</span>: [],</span><br><span class="line">	<span class="attr">"seccomp-profile"</span>: <span class="string">""</span>,</span><br><span class="line">	<span class="attr">"insecure-registries"</span>: [],</span><br><span class="line">	<span class="attr">"no-new-privileges"</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">"default-runtime"</span>: <span class="string">"runc"</span>,</span><br><span class="line">	<span class="attr">"oom-score-adjust"</span>: <span class="number">-500</span>,</span><br><span class="line">	<span class="attr">"node-generic-resources"</span>: [<span class="string">"NVIDIA-GPU=UUID1"</span>, <span class="string">"NVIDIA-GPU=UUID2"</span>],</span><br><span class="line">	<span class="attr">"runtimes"</span>: &#123;</span><br><span class="line">		<span class="attr">"cc-runtime"</span>: &#123;</span><br><span class="line">			<span class="attr">"path"</span>: <span class="string">"/usr/bin/cc-runtime"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">"custom"</span>: &#123;</span><br><span class="line">			<span class="attr">"path"</span>: <span class="string">"/usr/local/bin/my-runc-replacement"</span>,</span><br><span class="line">			<span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">				<span class="string">"--debug"</span></span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>docker container run，可用全部选项</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:	docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Run a <span class="built_in">command</span> <span class="keyword">in</span> a new container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --add-host list                  添加自定义主机到IP映射 (host:ip)</span><br><span class="line">  -a, --attach list                    附加到STDIN,STDOUT或STDERR</span><br><span class="line">      --blkio-weight uint16            阻止IO(相对权重),介于10和1000之间,或0阻止(默认为0)</span><br><span class="line">      --blkio-weight-device list       阻止IO权重(相对设备权重)(默认 [])</span><br><span class="line">      --<span class="built_in">cap</span>-add list                   添加Linux功能</span><br><span class="line">      --<span class="built_in">cap</span>-drop list                  删除Linux功能</span><br><span class="line">      --cgroup-parent string           容器的可选父cgroup</span><br><span class="line">      --cidfile string                 将容器ID写入文件</span><br><span class="line">      --cpu-period int                 限制CPU CFS(完全公平调度程序)期间</span><br><span class="line">      --cpu-quota int                  限制CPU CFS(完全公平调度程序)配额</span><br><span class="line">      --cpu-rt-period int              限制CPU实时周期(以微秒为单位)</span><br><span class="line">      --cpu-rt-runtime int             以微秒为单位限制CPU实时运行时间</span><br><span class="line">  -c, --cpu-shares int                 CPU份额(相对权重)</span><br><span class="line">      --cpus decimal                   CPU数量</span><br><span class="line">      --cpuset-cpus string             允许执行的CPU(0-3,0,1)</span><br><span class="line">      --cpuset-mems string             允许执行的MEM(0-3,0,1)</span><br><span class="line">  -d, --detach                         在后台运行容器并打印容器ID</span><br><span class="line">      --detach-keys string             覆盖用于分离容器的键序列</span><br><span class="line">      --device list                    将主机设备添加到容器中</span><br><span class="line">      --device-cgroup-rule list        将规则添加到cgroup允许的设备列表中</span><br><span class="line">      --device-read-bps list           限制设备的读取速率(每秒字节数)(默认为[])</span><br><span class="line">      --device-read-iops list          限制设备的读取速率(每秒IO)(默认为[])</span><br><span class="line">      --device-write-bps list          限制写入速率(每秒字节数)到设备(默认[])</span><br><span class="line">      --device-write-iops list         限制写入速率(每秒IO)到设备(默认[])</span><br><span class="line">      --<span class="built_in">disable</span>-content-trust          跳过图像验证(默认为<span class="literal">true</span>)</span><br><span class="line">      --dns list                       设置自定义DNS服务器</span><br><span class="line">      --dns-option list                设置DNS选项</span><br><span class="line">      --dns-search list                设置自定义DNS搜索域</span><br><span class="line">      --entrypoint string              覆盖图像的默认 ENTRYPOINT 例如：docker run -it --entrypoint /bin/sh busybox -c <span class="string">'echo ok'</span></span><br><span class="line">  -e, --env list                       设置环境变量</span><br><span class="line">      --env-file list                  读入环境变量文件</span><br><span class="line">      --expose list                    暴露端口或一系列端口</span><br><span class="line">      --group-add list                 添加其他组以加入</span><br><span class="line">      --health-cmd string              运行以检查运行状况的命令</span><br><span class="line">      --health-interval duration       运行检查之间的时间(ms|s|m|h) (默认 0s)</span><br><span class="line">      --health-retries int             报告不健康需要连续失败</span><br><span class="line">      --health-start-period duration   在开始运行状况重试倒计时之前初始化容器的开始时间段(ms|s|m|h) (默认 0s)</span><br><span class="line">      --health-timeout duration        允许一次检查运行的最长时间(ms|s|m|h) (默认 0s)</span><br><span class="line">      --<span class="built_in">help</span>                           打印用法</span><br><span class="line">  -h, --hostname string                容器主机名</span><br><span class="line">      --init                           在容器内运行init,转发信号并重新获取进程</span><br><span class="line">  -i, --interactive                    即使没有连接,也要保持STDIN打开</span><br><span class="line">      --ip string                      IPv4地址(例如,172.30.100.104)</span><br><span class="line">      --ip6 string                     IPv6地址(例如,2001:db8::33)</span><br><span class="line">      --ipc string                     使用IPC模式</span><br><span class="line">      --isolation string               容器隔离技术</span><br><span class="line">  -l, --label list                     在容器上设置元数据</span><br><span class="line">      --label-file list                读入行分隔的标签文件</span><br><span class="line">      --link list                      添加到另一个容器的链接</span><br><span class="line">      --link-local-ip list             容器IPv4 / IPv6链路本地地址</span><br><span class="line">      --<span class="built_in">log</span>-driver string              记录容器的驱动程序</span><br><span class="line">      --<span class="built_in">log</span>-opt list                   日志驱动程序选项</span><br><span class="line">      --mac-address string             容器MAC地址(例如,92:d0:c6:0a:29:33)</span><br><span class="line">  -m, --memory bytes                   内存限制</span><br><span class="line">      --memory-reservation bytes       内存软限制</span><br><span class="line">      --memory-swap bytes              交换限制等于内存加交换:<span class="string">'-1'</span> 以启用无限制交换</span><br><span class="line">      --memory-swappiness int          调整容器内存swappiness(0到100)(默认-1)</span><br><span class="line">      --oom-kill-disable               禁用 OOM 杀手</span><br><span class="line">      --oom-score-adj int              调整主机的 OOM 首选项(-1000到1000)</span><br><span class="line">      --kernel-memory bytes            内核内存限制</span><br><span class="line">      --mount mount                    将文件系统挂载附加到容器</span><br><span class="line">      --name string                    为容器指定名称</span><br><span class="line">      --network string                 将容器连接到网络(默认为<span class="string">"default"</span>)</span><br><span class="line">      --network-alias list             为容器添加网络范围的别名</span><br><span class="line">      --no-healthcheck                 禁用任何容器指定的 HEALTHCHECK</span><br><span class="line">      --pid string                     要使用的PID命名空间</span><br><span class="line">      --pids-limit int                 调整容器pids限制(设置-1为无限制)</span><br><span class="line">      --privileged                     为此容器授予扩展权限</span><br><span class="line">  -p, --publish list                   将容器的端口发布到主机</span><br><span class="line">  -P, --publish-all                    将所有公开的端口发布到随机端口</span><br><span class="line">      --<span class="built_in">read</span>-only                      将容器的根文件系统挂载为只读</span><br><span class="line">      --restart string                 重新启动容器退出时应用的策略(默认为<span class="string">"no"</span>)</span><br><span class="line">      --rm                             退出时自动删除容器</span><br><span class="line">      --runtime string                 用于此容器的运行时</span><br><span class="line">      --security-opt list              安全选项</span><br><span class="line">      --shm-size bytes                 / dev / shm的大小</span><br><span class="line">      --sig-proxy                      代理接收到进程的信号(默认为<span class="literal">true</span>)</span><br><span class="line">      --stop-signal string             用于停止容器的信号(默认为<span class="string">"SIGTERM"</span>)</span><br><span class="line">      --stop-timeout int               停止容器的超时(以秒为单位)</span><br><span class="line">      --storage-opt list               容器的存储驱动程序选项</span><br><span class="line">      --sysctl map                     Sysctl选项(默认map [])</span><br><span class="line">      --tmpfs list                     挂载tmpfs目录</span><br><span class="line">  -t, --tty                            分配伪TTY</span><br><span class="line">      --<span class="built_in">ulimit</span> <span class="built_in">ulimit</span>                  Ulimit选项(默认[])</span><br><span class="line">  -u, --user string                    用户名或UID(格式: &lt;name|uid&gt;[:&lt;group|gid&gt;])</span><br><span class="line">      --userns string                  要使用的用户名称空间</span><br><span class="line">      --uts string                     要使用的UTS名称空间</span><br><span class="line">  -v, --volume list                    绑定一个卷</span><br><span class="line">      --volume-driver string           容器的可选卷驱动程序</span><br><span class="line">      --volumes-from list              从指定容器装载卷</span><br><span class="line">  -w, --workdir string                 容器内的工作目录</span><br></pre></td></tr></table></figure>
<h1 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h1><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>在 Linux 中提供了对网络名称空间进行操作的命令，可以将创建的虚拟网卡移动到一个指定的命名空间。</p>
<ul>
<li>ip 网络命名空间相关命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip netns list                             # 列出网络名称空间</span><br><span class="line">ip netns add NAME                         # 添加网络名称空间</span><br><span class="line">ip netns set NAME NETNSID                 # 设置网络名称空间的 SID</span><br><span class="line">ip [-all] netns delete [NAME]             # 删除网络名称空间</span><br><span class="line">ip netns identify [PID]                   #  </span><br><span class="line">ip netns pids NAME                        # </span><br><span class="line">ip [-all] netns exec [NAME] cmd ...       # 在网络名称空间中执行命令</span><br><span class="line">ip netns monitor                          #</span><br><span class="line">ip netns list-id                          #</span><br><span class="line">ip link set                               # 移动设备到指定的网络名称空间</span><br></pre></td></tr></table></figure>
<ul>
<li>创建名称空间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip netns add r1</span><br><span class="line">ip netns add r2</span><br></pre></td></tr></table></figure>
<ul>
<li>查看指定网络名称空间内网卡信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip netns exec r1 ip a                                   # 只有一个 lo 接口</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一对网卡</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip link add name veth1.1 type veth peer name veth1.2    # 使用 ip a 可以看到这两个网卡</span><br></pre></td></tr></table></figure>
<ul>
<li>将虚拟网卡移动到指定的名称空间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip link set dev veth1.2 netns r1                        # 将一个网卡移动到 r1 名称空间</span><br></pre></td></tr></table></figure>
<ul>
<li>现在查看</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip netns exec r1 ip a</span><br></pre></td></tr></table></figure>
<ul>
<li>在指定网络名称空间执行命令，修改网卡的名称</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip netns exec r1 ip link set dev veth1.2 name eth0</span><br></pre></td></tr></table></figure>
<ul>
<li>将刚创建的两个虚拟网卡中的 veth1.1 激活，并且将另外一般也激活，这样两块网卡就能通信了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip addr add 10.0.0.1/24 dev veth1.1                      # 为在宿主机一端的网卡设置 IP 地址</span><br><span class="line">ip link set dev veth1.1 up                               # 启动宿主机一端的网卡</span><br><span class="line"></span><br><span class="line">ip netns exec r1 ip addr add 10.0.0.2/24 dev eth0        # 为 r1 名称空间的网卡设置IP地址</span><br><span class="line">ip netns exec r1 ip link set dev eth0 up                 # 启动 r1 名称空间的网卡</span><br><span class="line">ping 10.0.0.2                                            # 现在宿主机与 r1 可以通信</span><br></pre></td></tr></table></figure>
<ul>
<li>将 veth1 网卡移动到 r2 的名称空间，现在两个名称空间的网卡就可以通信了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip link set dev veth1.1 netns r2                         # 移动 veth1.1 到 r2 名称空间</span><br><span class="line">ip netns exec r2 ip link set dev veth1.1 name eth0       # 配置 r2 名称空间的网卡名字</span><br><span class="line">ip netns exec r2 ip addr add 10.0.0.3/24 dev eth0        # 配置 r2 名称空间的网卡 ip</span><br><span class="line">ip netns exec r2 ip link set dev eth0 up                 # 启动 r2 名称空间的网卡</span><br><span class="line">ip netns exec r2 ping 10.0.0.2                           # 在 r2 中与 r1 通信</span><br></pre></td></tr></table></figure>
<h2 id="Docker-网络模式"><a href="#Docker-网络模式" class="headerlink" title="Docker 网络模式"></a>Docker 网络模式</h2><ul>
<li>Docker 安装后默认会创建三种模式的网络，可以通过 <code>docker network ls</code> 查看</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">bdad94c4064f        bridge              bridge              <span class="built_in">local</span>          <span class="comment"># 一个 NAT 网络桥，容器默认加入的网络，Docker 默认网络</span></span><br><span class="line">77c50bc6c253        host                host                <span class="built_in">local</span>          <span class="comment"># 和宿主机共享网络名称空间，直接操作宿主机网络</span></span><br><span class="line">1e42d83b5291        none                null                <span class="built_in">local</span>          <span class="comment"># 除了 lo 接口，没有任何网络</span></span><br></pre></td></tr></table></figure>
<ul>
<li>默认网络</li>
</ul>
<p>在宿主机上可以看到的 docker0，它是一个网桥，同时是一个 NAT 桥，它就是 Docker 默认的网络，它为接入的容器自动分配一个地址，每当启动一个容器，Docker 会虚拟出来一对网卡接口（像网线一样有两头），一个接口在容器内，另一个接口接入 宿主机的 docker0 交换机上。</p>
<ul>
<li>在宿主机上查看网卡信息，<code>ip addr</code>，可以看到 docker0 和容器的网卡</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default </span><br><span class="line">    link/ether 02:42:50:78:2f:4d brd ff:ff:ff:ff:ff:ff</span><br><span class="line">8: veth974bf58@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default </span><br><span class="line">    link/ether 82:94:17:89:09:dc brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">10: veth146e765@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default </span><br><span class="line">    link/ether de:3d:0c:76:49:43 brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">12: vethcf3ebe2@if11: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default </span><br><span class="line">    link/ether 9e:2b:60:34:3f:84 brd ff:ff:ff:ff:ff:ff link-netnsid 2</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用 <code>brctl</code> 或者 <code>docker network inspect bridge</code> 来查看网络拓扑，需要安装 <code>yum install bridge-utils</code>，执行命令：<code>brctl show</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bridge    name    bridge            id    STP    enabled    interfaces</span><br><span class="line">docker0           8000.024250782f4d       no                veth146e765</span><br><span class="line">                                                            veth974bf58</span><br><span class="line">                                                            vethcf3ebe2</span><br></pre></td></tr></table></figure>
<ul>
<li>Docker0 网桥如何通信</li>
</ul>
<p>Docker0 桥接到宿主机的物理网卡上，物理网卡的报文也会收到一份，同时 Docker0 工作在 NAT 模式下，所有容器的虚拟网卡都连接到 Docker0 这个网桥的 NAT 网络下，所以从容器发出的报文会经过 Docker0 的 SNAT 到主机外部，从主机外部发来的报文会经过 DNAT 到达容器。</p>
<h2 id="自定义docker0"><a href="#自定义docker0" class="headerlink" title="自定义docker0"></a>自定义docker0</h2><ul>
<li>自定义 docker0 桥的网络信息，<code>vim /etc/docker/daemon.json</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"bip"</span>: <span class="string">"192.168.1.0/24"</span>,</span><br><span class="line">    <span class="string">"fixed-cidr"</span>: <span class="string">"10.20.0.0/16"</span>,</span><br><span class="line">    <span class="string">"fixed-cidr-v6"</span>: <span class="string">"2001:db8::/64"</span>,</span><br><span class="line">    <span class="string">"mtu"</span>: 1500,</span><br><span class="line">    <span class="string">"default-gateway"</span>: <span class="string">"10.20.1.1"</span>,</span><br><span class="line">    <span class="string">"default-gateway-v6"</span>: <span class="string">"2001:db8:abcd::89"</span>,</span><br><span class="line">    <span class="string">"dns"</span>: [<span class="string">"10.20.1.2"</span>,<span class="string">"10.20.1.3"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">核心选项为：bip，即 bridge ip 之意，用于指定 docker0 桥自身 IP 地址，其他选项可通过此地址计算得出</span><br></pre></td></tr></table></figure>
<h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><ul>
<li>设置容器的主机名称</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container run -it --rm --name my_busybox --hostname my_busybox busybox</span><br></pre></td></tr></table></figure>
<ul>
<li>设置容器的 DNS 服务器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container run -it --rm --name my_busybox --dns 8.8.8.8 busybox</span><br></pre></td></tr></table></figure>
<ul>
<li>添加域名解析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container run -it --rm --add-host www.yangjinheng.com:2.2.2.2 busybox</span><br></pre></td></tr></table></figure>
<h2 id="指定网络模式"><a href="#指定网络模式" class="headerlink" title="指定网络模式"></a>指定网络模式</h2><ul>
<li>创建容器时指定网络，<code>--network string</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run [OPTIONS] --network string IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>
<ul>
<li>Docker 网络模式</li>
</ul>
<table>
<thead>
<tr>
<th>网络</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bridge</code></td>
<td>每个容器有自己的名称空间，都加入 docker0 网络，可以互相通信、访问外部、宿主机可以直接访问，但从互联网不能访问容器</td>
</tr>
<tr>
<td><code>joined</code></td>
<td>联盟网络，两个容器使用相同的网络名称空间，它们使用相同的 IP 地址，结果就是两个容器可以直接通过 127.0.0.1 通信</td>
</tr>
<tr>
<td><code>host</code></td>
<td>开放式容器，容器使用宿主机的网络名称空间，意味着容器与宿主机的网络不隔离，同样容器可以直接对宿主机的网络进行修改</td>
</tr>
<tr>
<td><code>null</code></td>
<td>没有网络，意味着除了有 <code>lo</code> 接口之外，没有任何网络</td>
</tr>
</tbody>
</table>
<ul>
<li>命令帮助</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:	docker network COMMAND</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  ls          <span class="comment"># 列出网络</span></span><br><span class="line">  connect     <span class="comment"># 将容器连接到网络</span></span><br><span class="line">  disconnect  <span class="comment"># 断开容器与网络的连接</span></span><br><span class="line">  create      <span class="comment"># 创建一个网络</span></span><br><span class="line">  inspect     <span class="comment"># 显示一个或多个网络的详细信息</span></span><br><span class="line">  prune       <span class="comment"># 删除所有未使用的网络</span></span><br><span class="line">  rm          <span class="comment"># 删除一个或多个网络</span></span><br></pre></td></tr></table></figure>
<h2 id="开放式容器"><a href="#开放式容器" class="headerlink" title="开放式容器"></a>开放式容器</h2><ul>
<li>启动容器时候指定网路类型为 HOST</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it --rm --network host --name b2  busybox</span><br></pre></td></tr></table></figure>
<ul>
<li>在宿主机查看 80端口，<code>netstat -tnl |grep 80</code>，已经处于监听</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcp6    0    0    :::80    :::*    LISTEN</span><br></pre></td></tr></table></figure>
<h2 id="联盟式网络"><a href="#联盟式网络" class="headerlink" title="联盟式网络"></a>联盟式网络</h2><p>联盟式网络就是两个容器使用相同的网络命名空间，它们彼此可以通过 127.0.0.1 进行通信</p>
<ul>
<li>启动第一个容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it --rm --name b1 busybox</span><br></pre></td></tr></table></figure>
<ul>
<li>启动第二个容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it --rm --network container:b1 --name b2  busybox</span><br></pre></td></tr></table></figure>
<ul>
<li>对比网卡信息，发现两个容器处于同一个网络命名空间了，使用相同 IP 地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>
<ul>
<li>基于联盟式网络的LNMT架构，Nginx 通过 127.0.0.1 就能访问到 Tomcat 同时 Tomcat 也可以直接访问 My-sql</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Nginx + Tomcat + Mysql</span><br><span class="line">  |       |       |</span><br><span class="line">    \     |     /</span><br><span class="line">      \   |   /</span><br><span class="line">      联盟式网络</span><br><span class="line">          |</span><br><span class="line">       物理网卡</span><br></pre></td></tr></table></figure>
<h2 id="容器间互联"><a href="#容器间互联" class="headerlink" title="容器间互联"></a>容器间互联</h2><p>容器的连接（linking）系统是除了端口映射外，另一种跟容器中应用交互的方式。该系统会在源和接收容器之间创建一个隧道，接收容器可以看到源容器指定的信息，这种方式可以后可能被废弃。</p>
<ul>
<li>运行两个容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --rm --name node1 nginx</span><br><span class="line">docker run -d --rm --name node2 nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>运行第三个容器，链接到 node1、node2 节点实现负载均衡</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name lb -it --rm -p 80:80 -v /root/nginx.conf:/etc/nginx/nginx.conf --link node1 --link node2 nginx</span><br></pre></td></tr></table></figure>
<h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><ul>
<li>查看 Docker 支持的网络，<code>docker info</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Network: </span><br><span class="line">    bridge       # 桥</span><br><span class="line">    host         # 主机</span><br><span class="line">    macvlan      # 有 vlan 技术的网络</span><br><span class="line">    null         # 无网络</span><br><span class="line">    overlay      # 隧道叠加网络</span><br></pre></td></tr></table></figure>
<ul>
<li>创建网络</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create -d bridge --subnet <span class="string">"172.26.0.0/16"</span> --gateway <span class="string">"172.26.0.1"</span> mybr0</span><br></pre></td></tr></table></figure>
<ul>
<li>容器指定加入自定义的网络</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it --name b1 --rm --network mybr0 busybox</span><br></pre></td></tr></table></figure>
<h2 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h2><ul>
<li>随机映射端口，容器的指定端口映射到主机的指定 IP 地址+随机端口，-p 选项可使用多次</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run --name myweb -it --rm -p 80 nginx:stable-alpine</span><br><span class="line">docker container run --name myweb -it --rm -p 172.16.100.253::80 nginx:stable-alpine</span><br></pre></td></tr></table></figure>
<ul>
<li>指定映射端口，容器的指定端口映射到主机的指定 IP 地址 + 端口，-p 选项可使用多次</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run --name myweb -it --rm -p 80:80 nginx:stable-alpine</span><br><span class="line">docker container run --name myweb -it --rm -p 172.16.100.253:8080:80 nginx:stable-alpine</span><br></pre></td></tr></table></figure>
<ul>
<li>随机映射容器所有端口，将容器计划暴漏的所有端口全部映射至主机的随机端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run --name myweb -it --rm -P nginx:stable-alpine</span><br></pre></td></tr></table></figure>
<ul>
<li>查看指定容器 IP 端口映射</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container port myweb        <span class="comment"># 查看随机映射到的端口</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -vnL               <span class="comment"># 查看随机映射到的端口</span></span><br></pre></td></tr></table></figure>
<h1 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h1><p>在 Docker 中运行的程序如果需要存储数据，那么默认会保存在容器层状文件系统的最顶层，也就是读写层，这其中还用到了写时复制的过程，所以存储性能一般都比较低，但是最重要的一点是，如果程序需要持久存储数据，那么这个容器就不能删除，因为如果删除容器那么其数据将全部丢失，所以存在以下几个问题：</p>
<ol>
<li>存储于联合文件系统中，不易于宿主机访问</li>
<li>容器间数据共享不方便</li>
<li>删除容器就会丢失数据</li>
</ol>
<p>Docker 为容器持久存储数据提供了一个解决方案：卷（volume），卷是容器上的一个或多个目录，此类目录可绕过联合文件系统，与宿主机上某目录进行绑定关联。</p>
<h2 id="卷的类型"><a href="#卷的类型" class="headerlink" title="卷的类型"></a>卷的类型</h2><p>Docker有两种类型的卷，每种类型都在容器中存在一个挂载点，但其在宿主机上的位置有所不同。</p>
<ol>
<li>绑定挂载卷，用户指定宿主机关联的目录。</li>
<li>Docker自行管理的卷，一般位于：<code>/var/lib/docker/volumes/&lt;some_volume_id&gt;</code>。</li>
</ol>
<h2 id="Docker管理卷"><a href="#Docker管理卷" class="headerlink" title="Docker管理卷"></a>Docker管理卷</h2><ul>
<li>创建容器时指定Docker管理卷</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it --rm --name b1 -v /opt/docker busybox</span><br></pre></td></tr></table></figure>
<ul>
<li>查看卷的信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container inspect -f &#123;&#123;.Mounts&#125;&#125; b1</span><br></pre></td></tr></table></figure>
<h2 id="绑定挂载卷"><a href="#绑定挂载卷" class="headerlink" title="绑定挂载卷"></a>绑定挂载卷</h2><ul>
<li>创建容器时候指定绑定挂载卷</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it --rm --name b2 -v /opt/docker:/opt/docker busybox</span><br></pre></td></tr></table></figure>
<ul>
<li>查看卷的信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container inspect -f &#123;&#123;.Mounts&#125;&#125; b2</span><br></pre></td></tr></table></figure>
<h2 id="容器共享卷"><a href="#容器共享卷" class="headerlink" title="容器共享卷"></a>容器共享卷</h2><ul>
<li>复制指定容器的卷信息，使用其他容器的卷，而这个容器可以没有启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it --name b4 --volumes-from b3 busybox</span><br></pre></td></tr></table></figure>
<ul>
<li>启动第一个容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it --rm --name b3 -v /opt/docker:/opt/docker busybox</span><br></pre></td></tr></table></figure>
<ul>
<li>启动第二个容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it --name b4 --volumes-from b3 busybox</span><br></pre></td></tr></table></figure>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>Dockerfile 是由一系列命令和参数构成的脚本，一个 Dockerfile 里面包含了构建整个 image 的完整命令。Docker通过 <code>docker build</code> 依次执行  Dockerfile 中的一系列命令来构建 image，各命令独立运行，比如，即便使用 <code>RUN cd /home/hello</code> 切换工作目录，也不影响后面的命令。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>需要注意</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Dockerfile 每一条指令都会生成一个新层，所以应该指令应该精心设计从而减少层数</span><br><span class="line">2. Dockerfile 的命令不区分大小写，但一般使用大写</span><br><span class="line">3. 使用 # 表示注释，使用 \ 表示转义和续行</span><br><span class="line">4. JSON 数组中应该使用双引号而不是单引号</span><br><span class="line">5. 通常会为新的 Dockerfile 新建一个空目录，目录中只存放与镜像相关的文件</span><br></pre></td></tr></table></figure>
<ul>
<li><code>.dockerignore</code>，忽略配置文件</li>
</ul>
<p>构建过程的第一件事是将整个上下文（递归地）将文件发送到守护进程，所以可以配置 <code>.dockerignore</code> 文件来排除文件和目录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># comment</span><br><span class="line">*/temp*      # 排除路径中包含 /temp 的所有文件和目录，例如：/temporary.txt 和 /temp/test</span><br><span class="line">*/*/temp*    # 排除任何目录下路径中包含 /tmp 的所有文件和目录，例如：/subdir/temporary.txt</span><br><span class="line">temp?        # 排除根目录中的文件和目录，例如：/tempa与/tempb 被排除在外</span><br></pre></td></tr></table></figure>
<ul>
<li>使用.dockerignore文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在 Dockerfile 目录下新建一个 .dockerignore 件来指定要忽略的文件和目录。.dockerignore 文件的排除模式语法和 Git 的 .gitignore 文件相似。</span><br></pre></td></tr></table></figure>
<ul>
<li>多阶段构建</li>
</ul>
<p>Docker 17.05 版本以后，官方就提供了一个新的特性：Multi-stage builds（多阶段构建），你可以使用多阶段构建 来减少所构建镜像的大小，使用多阶段构建，你可以在一个 Dockerfile 中使用多个 FROM 语句。每个 FROM 指令都可以使用不同的基础镜像，并表示开始一个新的构建阶段。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang AS build-<span class="keyword">env</span>                                                  <span class="comment"># 阶段 1</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /go/src/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src/app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> go get -u -v github.com/kardianos/govendor</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> govendor sync</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> GOOS=linux GOARCH=386 go build -v -o /go/src/app/app-server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add -U tzdata</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -sf /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --from=build-env /go/src/app/app-server /usr/<span class="built_in">local</span>/bin/app-server   <span class="comment"># 拷贝阶段 1 构建的文件</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">"app-server"</span> ]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>避免不必要的包</li>
</ul>
<p>为了降低复杂性、减少依赖、减小文件大小和构建时间，应该避免安装额外的或者不必要的软件包。例如，不要在数据库镜像中包含一个文本编辑器。</p>
<ul>
<li>一个容器只做一件事情</li>
</ul>
<p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如一个 web 应用程序可能包含三个独立的容器：web应用、数据库、缓存，每个容器都是独立的镜像，分开运行。但这并不是说一个容器就只跑一个进程，因为有的程序可能会自行产生其他进程，比如 Celery 就可以有很多个工作进程。虽然“每个容器跑一个进程”是一条很好的法则，但这并不是一条硬性的规定。我们主要是希望一个容器只关注一件事情，尽量保持干净和模块化。</p>
<ul>
<li>最小化镜像层数</li>
</ul>
<p>在 Docker 17.05 甚至更早 1.10之 前，尽量减少镜像层数是非常重要的，不过现在的版本已经有了一定的改善了：</p>
<p>在 1.10 以后，只有 RUN、COPY 和 ADD 指令会创建层，其他指令会创建临时的中间镜像，但是不会直接增加构建的镜像大小了。<br>上节课我们也讲解到了 17.05 版本以后增加了多阶段构建的支持，允许我们把需要的数据直接复制到最终的镜像中，这就允许我们在中间阶段包含一些工具或者调试信息了，而且不会增加最终的镜像大小。</p>
<p>当然减少RUN、COPY、ADD的指令仍然是很有必要的，但是我们也需要在 Dockerfile 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。</p>
<ul>
<li>写的很好的一些官方对象，可以作为参考</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/docker-library/docs</span><br></pre></td></tr></table></figure>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><ul>
<li>构建镜像并设置镜像标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t yangjinheng:latest ./</span><br></pre></td></tr></table></figure>
<ul>
<li>启动容器时候通过设置环境变量改变容器运行特性</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run --env WEBSERVER_PACKAGE=<span class="string">"nginx-1.15.1"</span></span><br></pre></td></tr></table></figure>
<h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p>指定基于的基础镜像，Dockerfile 一般总是以 FROM 起始，ARG 指令是 Dockerfile 中唯一可以在 FROM 之前的指令，关于基础镜像，推荐使用：alpine，它是一个完整的发行版，但只有 5M</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt; [AS &lt;name&gt;]             # 引用仓库的 latest 版本</span><br><span class="line">FROM &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]     # 使用仓库 + 标签</span><br><span class="line">FROM &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]  # 使用仓库 + hash 码来引用</span><br></pre></td></tr></table></figure>
<ul>
<li>示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stretch-slim</span><br></pre></td></tr></table></figure>
<h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><p>指令设置生成的镜像中的作者信息，在新版本中弃用，已经被替换为：LABEL 标签。</p>
<ul>
<li>MAINTAINER 语法</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>LABEL 指令可以设置您需要的任何元数据，并且可以使用 <code>docker inspec</code> 查看。同样设置 MAINTAINER 信息就可以使用键值方式设置</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"jinhengyang@foxmail.com&gt;"</span></span></span><br></pre></td></tr></table></figure>
<h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p>用于从主机复制文件至创建的新镜像文件</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>]    <span class="comment"># 文件名中有空格等特殊字符时候使用这种 JSON 数组方式</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &lt;src&gt; 必须在 Dockerfile 所在的当前目录</span><br><span class="line">2. &lt;dest&gt; 必须使用容器的绝对路径</span><br><span class="line">3. &lt;dest&gt; 文件名不以 / 结尾则视为常规文件，使用 / 结尾表示一个目录</span><br><span class="line">4. &lt;src&gt; 如果是目录，则只递归复制目录内容，不复制目录本身</span><br><span class="line">5. &lt;src&gt; 支持通配符，如果 &lt;src&gt; 为多个那么 &lt;dest&gt; 只能为目录</span><br><span class="line">6. &lt;dest&gt; 如果不存在，则递归创建其父目录</span><br><span class="line">7. &lt;user&gt; &lt;group&gt; 可以使用 UID / GID 或用户名和组名，缺省为 root</span><br></pre></td></tr></table></figure>
<ul>
<li>示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> hom* /mydir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=docker files* /somedir/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> --chown=10:11 files* /somedir/</span></span><br></pre></td></tr></table></figure>
<h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p>类似COPY指令，ADD支持使用TAR文件和URL路径，会自动展开本地TAR ，从 URL下载文件，而网络上的TAR文件不自动展开。</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> [--chown=&lt;user&gt;:&lt;group&gt;] [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>]    <span class="comment"># 文件名中有空格等特殊字符时候使用这种 JSON 数组方式</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 包含 COPY 指令的全部使用规则</span><br><span class="line">2. &lt;src&gt; 可以是文件、tar归档文件、目录、URL</span><br><span class="line">3. &lt;src&gt; 是 identity,gzip,bzip2,xz 的本地 tar 存档文件，则将其自动展开为目录，但 URL 不做展开</span><br><span class="line">4. ADD 指令是根据文件内容来判断是否为归档文件的，与扩展名无关</span><br><span class="line">5. 如果 &lt;src&gt; 是 URL，&lt;dest&gt; 是文件则下载文件名为文件名，如果是目录，则使用 URL 文件名下载保存到目录</span><br></pre></td></tr></table></figure>
<ul>
<li>例如</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> https://nginx.org/download/nginx-1.14.0.tar.gz /usr/<span class="built_in">local</span>/src/</span></span><br></pre></td></tr></table></figure>
<h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p>用于为 Dockerfile 中任何 RUN、CMD、ENTRYPOINT、COPY、ADD 指令设定工作目录，如果 WORKDIR 不存在，则会自动创建；</p>
<p>WORKDIR指令可以出现多次，每次影响后面的指令，如果使用相对路径，则表示是相对于前一条 WORKDIR 指令的路径；</p>
<p>WORKDIR 可以解析 ENV 指令设置的环境变量；</p>
<ul>
<li>示例，下面使用相对路径，那么最终的结果为 <code>/a/b/c</code></li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DIRPATH /path</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$DIRPATH</span>/<span class="variable">$DIRNAME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>
<h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><p>为容器指定创建一个卷的挂载点，这个卷是由 Docker 管理的卷，也可以是 JSON 格式的数组。</p>
<ul>
<li>语法和示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /data</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/data"</span>]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 如果挂载点路径下有文件存在，则 Docker 在卷挂载完成后将此前的目录中的文件复制到新挂载的卷中</span><br></pre></td></tr></table></figure>
<h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p>通知容器在运行时候会监听的端口和协议，如果没有指定协议，默认为TCP，EXPOSE 指令不会主动在容器启动后不会映射宿主机端口，它只作为一个待映射的名单，当使用 -P 参数运行容器的时候，会按照 EXPOSE 指定的端口与宿主机随机映射。</p>
<ul>
<li>语法和规则</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 无论 EXPOSE 设置如何，都可以在容器运行时使用 -p 选项覆盖</span><br></pre></td></tr></table></figure>
<ul>
<li>示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure>
<h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p>为容器运行时设置环境变量，</p>
<ul>
<li>语法和规则</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一种形式 &lt;key&gt; 之后的所有内容均被视作 &lt;value&gt;</span><br><span class="line">1. 第二种形式可以设置多个变量</span><br><span class="line">2. 在后续引用时候可以使用变量扩展的形式</span><br><span class="line">3. 支持 ENV 的指令有：ADD,COPY,ENV,EXPOSE,FROM,LABEL,STOPSIGNAL,USER,VOLUME,WORKDIR,ONBUILD</span><br></pre></td></tr></table></figure>
<ul>
<li>示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MYNAME Yangjinheng</span><br><span class="line"><span class="keyword">ENV</span> MYNAME=<span class="string">"Yangjinheng"</span> \</span><br><span class="line">    MYDOG=Rex\ The\ Dog \</span><br><span class="line">    MYCAT=fluffy</span><br></pre></td></tr></table></figure>
<ul>
<li>引用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$MYNAME    # Yangjinheng</span><br><span class="line">$MYDOG     # Rex The Dog</span><br><span class="line">$MYCAT     # fluffy</span><br></pre></td></tr></table></figure>
<ul>
<li>变量扩展形式引用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;AGE:-29&#125;</span>          <span class="comment"># 表示 AGE 不存在则值替换为 29，如果 AGE 存在 则为 $AGE</span></span><br><span class="line"><span class="variable">$&#123;MYCAT:+mimi&#125;</span>      <span class="comment"># 表示 MYCAT 存在则值替换为 mimi ，如果 MYCAT 存在则替换为空</span></span><br></pre></td></tr></table></figure>
<h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p>设置容器编为镜像的段运行的命令，运行命令的结果将在生成的镜像中。</p>
<ul>
<li>语法1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN &lt;command&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 这种方式命令在 shell 中运行，默认情况下以 /bin/sh -c 方式执行，其执行结果会提交为镜像的一个新层，所以应该使用 &amp;&amp; 连接多个命令。</span><br></pre></td></tr></table></figure>
<ul>
<li>语法1 示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">set</span> -x \</span></span><br><span class="line"><span class="bash">	&amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">	&amp;&amp; apt-get install -y --no-install-recommends ca-certificates wget \</span></span><br><span class="line"><span class="bash">	&amp;&amp; apt-get purge -y --auto-remove ca-certificates wget</span></span><br></pre></td></tr></table></figure>
<ul>
<li>语法2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 这种方式命令直接使用内核 exec 函数，由于没有 shell 环境，所以 $ 符号、通配符等 shell 特性不能被解析；</span><br><span class="line">2. 需要使用 shell 特性可以使用 RUN [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;] ，这还可以改变默认的 /bin/sh 来执行指令；</span><br></pre></td></tr></table></figure>
<ul>
<li>语法2 示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, <span class="string">"echo hello"</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, <span class="string">"set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l &gt; /number"</span>]</span></span><br></pre></td></tr></table></figure>
<h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>为容器的运行阶段执行的默认命令，它可以包含执行文件，也可以省略执行文件而当作为 ENTRYPOINT 设置的命令提供默认参数（可被用户覆盖）。</p>
<ul>
<li>前提知识</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 在 Linux 中 PID 为 1 的进程称之为 INIT 进程，所有的进程都是它的子进程，同时在 Linux 中如果父进程结束，那么在退出之前会结束所有子进程；</span><br><span class="line">2. 在 Docker 容器内一般只运行一个主进程，它的 PID 为 1，它可以接收 Docker 发来的 SIGTERM 信号来停止容器，其他进程都是它的子进程；</span><br><span class="line">3. 同时如果 PID 为 1 的进程退出，那么它将杀死所有的子进程，然后容器退出；</span><br><span class="line">4. 如果想让容器中的程序为主进程，那么就必须让它的 PID 为 ，才能决定容器的生命周期，才能接收 SIGTERM 信号主动停止容器；</span><br><span class="line">5. shell 有个参数 -c ，它可以实现 fork + exec，意思是首先 fock 子进程，使用子进程替换当前进程，这为使用 shell 启动主进程提供了一种方法。</span><br></pre></td></tr></table></figure>
<ul>
<li>语法1</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"executable"</span>,<span class="string">"param1"</span>,<span class="string">"param2"</span>]        <span class="comment"># 首选 JSON 数组形式</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"param1"</span>,<span class="string">"param2"</span>]                     <span class="comment"># 作为 ENTRYPOINT 的默认参数</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">command</span> param1 param2                   <span class="comment"># shell 方式</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Dockerfile 只能有一条 CMD 指令，存在多条，则最后一条生效</span><br><span class="line">2. CMD 的主要目的是为 ENTRYPOINT 提供默认的参数，必须使用 JSON 数组格式</span><br><span class="line">3. 注意 JSON 数组格式会使用内核 exec 函数，不识别 shell 的特性</span><br><span class="line">4. 如果使用 shell 形式，那么默认会使用 /bin/sh -c 执行指令</span><br><span class="line">5. 注意它与 RUN 指令的区别，RUN 运行在构建镜像期间，而 CMD 是容器运行期</span><br></pre></td></tr></table></figure>
<ul>
<li>JSON 数组形式，由内核 exec 调用启动</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/sh"</span>,<span class="string">"-c"</span>,<span class="string">"/bin/httpd -f -h <span class="variable">$WEB_DOC_ROOT</span>"</span>]    <span class="comment"># 如果参数有值那么应该同参数写在一个引号内，如运行 httpd 是 shell 的参数</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Cmd&quot;: [</span><br><span class="line">    &quot;/bin/sh&quot;,                                           # 内核启动 /bin/sh</span><br><span class="line">    &quot;-c&quot;,                                                # 同 exec 一样</span><br><span class="line">    &quot;/bin/httpd -f -h $WEB_DOC_ROOT&quot;                     # /bin/sh 启动 httpd 并识别 $ 变量</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<ul>
<li>shell 方式示例，由 shell 启动</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/httpd -f -h <span class="variable">$WEB_DOC_ROOT</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Cmd&quot;: [</span><br><span class="line">    &quot;/bin/sh&quot;,</span><br><span class="line">    &quot;-c&quot;,</span><br><span class="line">    &quot;/bin/httpd -f -h $WEB_DOC_ROOT&quot;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 /bin/httpd -f -h /data/web/html/   # 这里可以看出来 Docker 默认帮我们执行了 /bin/sh exec 模式</span><br><span class="line">    8 root      0:00 /bin/sh                            # exec 的结果就是使用子进程替换当前进程，进而 httpd 的 PID 为 1</span><br><span class="line">   15 root      0:00 ps</span><br></pre></td></tr></table></figure>
<ul>
<li>为 ENTRYPOINT 指令提供默认参数</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"docker-entrypoint.sh"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"mysqld"</span>]</span></span><br></pre></td></tr></table></figure>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>设置容器启动时运行的程序，它不会被用户启动容器时指定运行的指令所覆盖，并且用户指定的指令会作为参数放到 ENTRYPOINT 指令的后面。</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"param1"</span>, <span class="string">"param2"</span>]    <span class="comment"># exec 方式，首选</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2                 <span class="comment"># shell 方式</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 用户在启动容器传递的指令都会作为参数传递给 ENTRYPOINT，如：docker run -it yanghttpd ls /etc/ 被 ENTRYPOINT 接收</span><br></pre></td></tr></table></figure>
<ul>
<li>exec 方式 示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/usr/sbin/nginx"</span>,<span class="string">"-g"</span>,<span class="string">"daemon off;"</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/sh"</span>,<span class="string">"/bin/entrypoint.sh"</span>]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD 指令将被传递给 ENTRYPOINT 当做容器启动时候的默认参数，同时用户可以在启动容器时指定运行指令，会覆盖 CMD 的默认参数，传递给 ENTRYPOINT</span><br></pre></td></tr></table></figure>
<ul>
<li>shell 方式 示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> /bin/httpd -f -h <span class="variable">$WEB_DOC_ROOT</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置容器启动的程序，这种形式会使用 /bin/sh -c 来执行命令</span><br></pre></td></tr></table></figure>
<ul>
<li>明确覆盖镜像 ENTRYPOINT 所执行的命令来启动容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it --entrypoint <span class="string">"/bin/sh"</span> busybox -c <span class="string">'echo ok'</span>        // 覆盖 entrypoint 为 /bin/sh 并在后面传递参数，这中方式有违直觉</span><br><span class="line">docker container run -it --entrypoint <span class="string">""</span> busybox /bin/sh -c <span class="string">'echo ok'</span>       // 推荐使用这样的方法，覆盖 entrypoint 为空，然后在 cmd 中执行</span><br></pre></td></tr></table></figure>
<ul>
<li>一个 NGINX 的示例性项目，要求：启动容器时传递环境变量，从而改变 nginx 的运行</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx:stable-alpine</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="string">"yang &lt;jinhengyang@foxmail.com&gt;"</span></span></span><br><span class="line"><span class="keyword">ENV</span> NGX_DOC_ROOT=<span class="string">"/data/web/html/"</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> index.html <span class="variable">$&#123;NGX_DOC_ROOT&#125;</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> entrypoint.sh /bin/</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp</span><br><span class="line"></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --start-period=3s --interval=1m --timeout=3s \ <span class="comment"># 定义容器的健康状态检测，容器启动等待3秒开始1分钟检测一次健康，3s的超时</span></span></span><br><span class="line">    <span class="keyword">CMD</span><span class="bash"> wget -O -q -  http://<span class="variable">$&#123;IP:-0.0.0.0&#125;</span>:<span class="variable">$&#123;PORT:-80&#125;</span>/</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/usr/sbin/nginx"</span>,<span class="string">"-g"</span>,<span class="string">"daemon off;"</span>]                 <span class="comment"># 为 ENTRYPOINT 执行的指令传递参数</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/sh"</span>,<span class="string">"/bin/entrypoint.sh"</span>]                <span class="comment"># 默认启动</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh                                                 # entrypoint.sh 根据环境变量生成配置文件</span></span><br><span class="line">cat &gt; /etc/nginx/conf.d/www.conf &lt;&lt;EOF</span><br><span class="line">server &#123;</span><br><span class="line">        server_name <span class="variable">$HOSTNAME</span>;                            <span class="comment"># 这些变量从容器环境变量中取得 </span></span><br><span class="line">        listen <span class="variable">$&#123;IP:-0.0.0.0&#125;</span>:<span class="variable">$&#123;PORT:-80&#125;</span>;                <span class="comment"># 这些变量从容器环境变量中取得</span></span><br><span class="line">        root <span class="variable">$&#123;NGX_DOC_ROOT:-/usr/share/nginx/html&#125;</span>;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span>                                                 <span class="comment"># 以 fock + exec 方式 执行 CMD 传递的参数，确保 PID 为 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello word<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>                                       # index.html</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run --env PORT=80                        <span class="comment"># 启动容器时候传递参数，改变容器的环境变量，从而改变容器特性</span></span><br></pre></td></tr></table></figure>
<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>设置运行指令的用户，影响在该指令后的指令，RUN、CMD、ENTRYPOINT</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;] or</span><br><span class="line"><span class="keyword">USER</span> &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> patrick</span><br></pre></td></tr></table></figure>
<h2 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h2><p>容器健康检查，该指令告诉 Docker 如何判断容器它是否仍在工作，例如：判断一个程序在运行但是无法提供服务的容器。</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK [OPTIONS] CMD command           # 通过在容器内运行命令来检查容器运行状况</span><br><span class="line">HEALTHCHECK NONE                            # 禁用从基础映像继承的任何运行状况检查</span><br><span class="line"></span><br><span class="line">OPTIONS：</span><br><span class="line">    --interval=DURATION        # 检查间隔时间，默认 30s</span><br><span class="line">    --timeout=DURATION         # 超时时间，默认 30s，超时将视作失败</span><br><span class="line">    --start-period=DURATION    # 为主进程初始化预留的等待时间，默认 0s</span><br><span class="line">    --retries=N                # 几次判定为死亡，默认为 3 次</span><br><span class="line">CMD:</span><br><span class="line">    CMD                        # 可以是 CMD 指令，它的返回值 0 表示成功，1 表示失败</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Dockerfile中只能有一条指令。如果列出多个，则只有最后一个HEALTHCHECK生效。</span><br></pre></td></tr></table></figure>
<ul>
<li>示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="bash"> --interval=5m --timeout=3s \</span></span><br><span class="line"><span class="bash">  CMD curl -f http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure>
<h2 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h2><p>定于运行指令默认的 SHELL 程序，默认值为 <code>/bin/sh</code>，一般不做更改。</p>
<ul>
<li>语法和规则</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="bash"> [<span class="string">"executable"</span>, <span class="string">"parameters"</span>]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该SHELL指令可以多次出现。每条SHELL指令都会覆盖所有先前的SHELL指令，并影响所有后续指令。</span><br></pre></td></tr></table></figure>
<h2 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h2><p>STOPSIGNAL 能够更换 SIGTERM 信号，例如更换为 -9 信号，那么只有 -9 信号才能停止主进程。</p>
<ul>
<li>语法和示例用法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STOPSIGNAL 9</span><br></pre></td></tr></table></figure>
<h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p>接收构建期间向 Dockerfile 传递的变量，ARG 是 Dockerfile 中唯一可以在 FROM 之前的指令。</p>
<ul>
<li>示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> author=<span class="string">"yang"</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer=<span class="variable">$&#123;author&#125;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> busybox:$VERSION</span><br><span class="line"><span class="keyword">ARG</span> VERSION</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$VERSION</span> &gt; image_version</span></span><br></pre></td></tr></table></figure>
<ul>
<li>构建时向 Dockerfile 传递变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image build --build-arg &lt;varname&gt;=&lt;value&gt;</span><br></pre></td></tr></table></figure>
<h2 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h2><p>当镜像用作另一个 Dockerfie 作为基础镜像时，该 ONBUILD 指令向镜像被触发并执行后面的指令。</p>
<ul>
<li>语法</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> [INSTRUCTION]</span><br></pre></td></tr></table></figure>
<ul>
<li>示例</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">ADD</span><span class="bash"> . /app/src</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> /usr/<span class="built_in">local</span>/bin/python-build --dir /app/src</span></span><br></pre></td></tr></table></figure>
<h1 id="自建仓库"><a href="#自建仓库" class="headerlink" title="自建仓库"></a>自建仓库</h1><h2 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker-Registry"></a>Docker-Registry</h2><p>官方提供了 docker-distribution ，用来自建 Docker-Registry，部署的 Registry 有两个方式，一种是直接运行在宿主机的 Regsiry，一种是运行为容器。</p>
<h3 id="安装部署-1"><a href="#安装部署-1" class="headerlink" title="安装部署"></a>安装部署</h3><ul>
<li>安装 <code>docker-distribution</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-registry</span><br></pre></td></tr></table></figure>
<ul>
<li>vim /etc/docker-distribution/registry/config.yml，配置文件位置</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">registry</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">    <span class="attr">cache:</span></span><br><span class="line">        <span class="attr">layerinfo:</span> <span class="string">inmemory</span></span><br><span class="line">    <span class="attr">filesystem:</span></span><br><span class="line">        <span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span>      <span class="comment"># 仓库存储位置</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">    <span class="attr">addr:</span> <span class="string">:5000</span>                               <span class="comment"># 监听的端口</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker-distribution</span><br></pre></td></tr></table></figure>
<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><ul>
<li>设置 Docker 允许 HTTP 协议进行仓库通信，无论上传和下载都需要修改，vim /etc/docker/daemon.json。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"insecure-registries"</span>: [<span class="string">"template:5000"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为镜像打标</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image tag busybox:latest template:5000/busybox:latest</span><br></pre></td></tr></table></figure>
<ul>
<li>推送到仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image push template:5000/busybox</span><br></pre></td></tr></table></figure>
<ul>
<li>在另一个客户端拉取镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull template:5000/busybox</span><br></pre></td></tr></table></figure>
<h2 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h2><p>Harbor 是一个用于存储和分发 Docker 镜像的企业级 Registry 服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源 Docker Distribution。作为一个企业级私有 Registry 服务器，Harbor提供了更好的性能和安全。提升用户使用Registry构建和运行环境传输镜像的效率。Harbor 支持安装在多个 Registry 节点的镜像资源复制，镜像全部保存在私有 Registry 中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor 也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。</p>
<ul>
<li><code>基于角色的访问控制</code> - 用户与 Docker 镜像仓库通过“项目”进行组织管理，一个用户可以对多个镜像仓库在同一命名空间（project）里有不同的权限。</li>
<li><code>镜像复制</code> - 镜像可以在多个 Registry 实例中复制（同步）。尤其适合于负载均衡，高可用，混合云和多云的场景。</li>
<li><code>图形化用户界面</code> - 用户可以通过浏览器来浏览，检索当前 Docker 镜像仓库，管理项目和命名空间。</li>
<li><code>AD/LDAP</code> 支持 - Harbor 可以集成企业内部已有的 AD/LDAP，用于鉴权认证管理。</li>
<li><code>审计管理</code> - 所有针对镜像仓库的操作都可以被记录追溯，用于审计管理。</li>
<li><code>国际化</code> - 已拥有英文、中文、德文、日文和俄文的本地化版本。更多的语言将会添加进来。</li>
<li><code>RESTful API</code> - RESTful API 提供给管理员对于 Harbor 更多的操控, 使得与其它管理软件集成变得更容易。</li>
<li><code>部署简单</code> - 提供在线和离线两种安装工具， 也可以安装到 vSphere 平台(OVA方式)虚拟设备。</li>
</ul>
<h3 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h3><ul>
<li>安装指南</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md</span><br></pre></td></tr></table></figure>
<ul>
<li>下载地址，选择 offline</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/goharbor/harbor/releases</span><br><span class="line">https://storage.googleapis.com/harbor-releases/release-1.8.0/harbor-offline-installer-v1.8.0.tgz</span><br></pre></td></tr></table></figure>
<ul>
<li>安装依赖软件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-compose</span><br></pre></td></tr></table></figure>
<ul>
<li>解压文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar xf harbor-offline-installer-v1.5.2.tar -C /usr/local/ &amp;&amp; cd /usr/local/harbor/</span><br></pre></td></tr></table></figure>
<ul>
<li>编辑配置文件，vim /usr/local/harbor/harbor.cfg</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostname = template                             <span class="comment"># 修改为外部可以访问的域名</span></span><br><span class="line">harbor_admin_password = Harbor12345             <span class="comment"># 管理员密码</span></span><br><span class="line">db_password = root123                           <span class="comment"># My-sql 密码</span></span><br></pre></td></tr></table></figure>
<ul>
<li>开始安装，安装完成后会自动启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash install.sh</span><br></pre></td></tr></table></figure>
<h3 id="启动停止"><a href="#启动停止" class="headerlink" title="启动停止"></a>启动停止</h3><ul>
<li>启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/harbor/</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<ul>
<li>停止</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/harbor/</span><br><span class="line">docker-compose stop</span><br></pre></td></tr></table></figure>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><ul>
<li>打开网页，创建一个用户，再创建一个仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://172.16.100.253/</span><br></pre></td></tr></table></figure>
<ul>
<li>使用刚创建的普通用户登陆，创建一个项目</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://172.16.100.253/</span><br></pre></td></tr></table></figure>
<h3 id="推送镜像-1"><a href="#推送镜像-1" class="headerlink" title="推送镜像"></a>推送镜像</h3><ul>
<li>设置 Docker 允许 HTTP 协议进行仓库通信，无论上传和下载都需要修改，vim /etc/docker/daemon.json。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>],</span><br><span class="line">    <span class="attr">"insecure-registries"</span>: [<span class="string">"template:80"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为镜像打标</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image tag busybox:latest template:80/devel/busybox:latest</span><br></pre></td></tr></table></figure>
<ul>
<li>登陆私有仓库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login -u yangjinheng -p Jinheng890821 template:80</span><br></pre></td></tr></table></figure>
<ul>
<li>推送镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image push template:80                               <span class="comment"># 推送全部镜像</span></span><br><span class="line">docker image push template:80/devel/busybox:latest          <span class="comment"># 推送一个镜像</span></span><br></pre></td></tr></table></figure>
<h1 id="资源限制"><a href="#资源限制" class="headerlink" title="资源限制"></a>资源限制</h1><p>默认情况下，容器没有资源限制，可以使用主机内核调度程序允许的尽可能多的给定资源。Docker提供了控制容器可以使用的内存，CPU或块IO的方法。</p>
<h2 id="内存资源"><a href="#内存资源" class="headerlink" title="内存资源"></a>内存资源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:	docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      -m, --memory bytes               容器可以使用的最大内存量。如果设置此选项，则允许的最小值为4m（4兆字节）</span><br><span class="line">      --memory-reservation bytes       允许此容器交换到磁盘的内存量，需要首先设置 --memory 选项</span><br><span class="line">      --memory-swap bytes              交换限制等于内存加交换:<span class="string">'-1'</span> 以启用无限制交换</span><br><span class="line">      --memory-swappiness int          调整容器内存swappiness(0到100)(默认-1)</span><br><span class="line">      --oom-kill-disable               禁用 OOM 杀手</span><br><span class="line">      --oom-score-adj int              调整主机的 OOM 首选项(-1000到1000)</span><br></pre></td></tr></table></figure>
<ul>
<li>–memory-swap 与 –memory 的关系</li>
</ul>
<table>
<thead>
<tr>
<th><code>--memory-swap</code></th>
<th><code>--memory</code></th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>正数S</td>
<td>正数M</td>
<td>容器内存可用空间为S，其中 RAM 为 M，SWAP 为 S-M，若S=M，则表示容器没有内存</td>
</tr>
<tr>
<td>0 或 unset</td>
<td>正数M</td>
<td>若主机（Docker Host）启用了SWAP，则容器的可用的 SWAP为  2*M</td>
</tr>
<tr>
<td>-1</td>
<td>正数M</td>
<td>若主机（Docker Host）启用了SWAP，则容器可使用最大至主机上所有SWAP空间资源</td>
</tr>
</tbody>
</table>
<blockquote>
<p>  在容器内使用 free 命令看到的 swap 空间并不具有其展示出的空间指示意义。</p>
</blockquote>
<ul>
<li>OOM</li>
</ul>
<p>在 Linux 主机上，如果内核检测到没有足够的内存来执行重要的系统功能，它会抛出 OOME 或 Out of Memory 异常，并开始终止进程以释放内存。任何进程都会被杀死，包括 Docker 和其他重要的应用程序。如果错误的进程被杀死，这可以有效地降低整个系统。</p>
<p>Docker 尝试通过调整 Docker 守护程序上的 OOM 优先级来降低这些风险，以便它比系统上的其他进程更不可能被杀死。容器上的 OOM 优先级未调整。这使得单个容器被杀死的可能性比 Docker 守护程序或其他系统进程被杀死的可能性更大。</p>
<p>您不应试图通过在守护程序或容器上手动设置 <code>--oom-score-adj</code> 到极端负数，或通过在容器上设置 <code>--oom-kill-disable</code> 来绕过这些安全措施。</p>
<ul>
<li>限制容器内存大小</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name stress -it --rm --memory 256m lorel/docker-stress-ng:latest --vm 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONTAINER ID        NAME          CPU %          MEM USAGE / LIMIT   MEM %          NET I/O        BLOCK I/O           PIDS</span><br><span class="line">d5c609605bc4        stress        191.52%        255.9MiB / 256MiB   99.95%         578B / 0B      438MB / 1.7GB       5</span><br></pre></td></tr></table></figure>
<ul>
<li>关于 cgroups 的 oom 杀手</li>
</ul>
<p>当物理内存达到上限后，系统的默认行为是 kill 掉 cgroup 中继续申请内存的进程，那么怎么控制这样的行为呢？答案是配置 memory.oom_control</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sys/fs/cgroup/memory/memory.oom_control</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cgroup.event_control               # 用于eventfd的接口</span><br><span class="line">memory.usage_in_bytes              # 显示当前已用的内存</span><br><span class="line">memory.limit_in_bytes              # 设置/显示当前限制的内存额度</span><br><span class="line">memory.failcnt                     # 显示内存使用量达到限制值的次数</span><br><span class="line">memory.max_usage_in_bytes          # 历史内存最大使用量</span><br><span class="line">memory.soft_limit_in_bytes         # 设置/显示当前限制的内存软额度</span><br><span class="line">memory.stat                        # 显示当前cgroup的内存使用情况</span><br><span class="line">memory.use_hierarchy               # 设置/显示是否将子cgroup的内存使用情况统计到当前cgroup里面</span><br><span class="line">memory.force_empty                 # 触发系统立即尽可能的回收当前cgroup中可以回收的内存</span><br><span class="line">memory.pressure_level              # 设置内存压力的通知事件，配合cgroup.event_control一起使用</span><br><span class="line">memory.swappiness                  # 设置和显示当前的swappiness</span><br><span class="line">memory.move_charge_at_immigrate    # 设置当进程移动到其他cgroup中时，它所占用的内存是否也随着移动过去</span><br><span class="line">memory.oom_control                 # 设置/显示oom controls相关的配置</span><br><span class="line">memory.numa_stat                   # 显示numa相关的内存</span><br></pre></td></tr></table></figure>
<ul>
<li>动态修改内存限制</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"268435456"</span> &gt; /sys/fs/cgroup/memory/docker/9fa20d824b18.../memory.limit_in_bytes</span><br><span class="line"><span class="built_in">echo</span> 2000 &gt; /sys/fs/cgroup/cpu,cpuacct/docker/容器 ID/cpu.shares</span><br></pre></td></tr></table></figure>
<h2 id="CPU限制"><a href="#CPU限制" class="headerlink" title="CPU限制"></a>CPU限制</h2><p>默认情况下每个容器对主机CPU周期的访问权限是不受限制的，您可以设置各种约束来限制给定容器访问主机的CPU周期。大多数用户空间进程默认被 CFS 调度器调度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:	docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -c, --cpu-shares int                 CPU份额(相对比例)，如：三个容器，为1:2:5，那么可以是7:1:1，如果全部繁忙，那就按比例分配</span><br><span class="line">      --cpus decimal                   限制CPU数量，不限制CPU编号，例如，如果主机有两个CPU，设置--cpus=&quot;1.5&quot;，则容器最多保证一个半CPU</span><br><span class="line">      --cpuset-cpus string             限制运行在哪些CPU编号，(0-3,0,1)</span><br><span class="line">      --cpu-period int                 限制CPU CFS(完全公平调度程序)期间</span><br><span class="line">      --cpu-quota int                  限制CPU CFS(完全公平调度程序)配额</span><br><span class="line">      --cpu-rt-period int              限制CPU实时周期(以微秒为单位)</span><br><span class="line">      --cpu-rt-runtime int             以微秒为单位限制CPU实时运行时间</span><br><span class="line">      --cpuset-mems string             允许执行的MEM(0-3,0,1)</span><br></pre></td></tr></table></figure>
<ul>
<li>下面的指令会保证容器每秒最多占CPU的50％</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name stress -it --rm --cpus=&quot;.5&quot; lorel/docker-stress-ng:latest --cpu 8</span><br></pre></td></tr></table></figure>
<ul>
<li>分配两个CPU，如果有八颗CPU，则按比例分两个，就是占用 200%</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name stress -it --rm --cpus 2 lorel/docker-stress-ng:latest --cpu 8</span><br><span class="line"></span><br><span class="line">CONTAINER ID        NAME       CPU %      MEM USAGE / LIMIT      MEM %      NET I/O             BLOCK I/O           PIDS</span><br><span class="line">98852c2796cc        stress     200.00%    15.82MiB  / 1.935GiB   0.80%      648B / 0B           0B / 0B             9</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONTAINER ID        NAME       CPU %      MEM USAGE / LIMIT      MEM %      NET I/O             BLOCK I/O           PIDS</span><br><span class="line">98852c2796cc        stress     200.00%    15.82MiB  / 1.935GiB   0.80%      648B / 0B           0B / 0B             9</span><br></pre></td></tr></table></figure>
<ul>
<li>按份额划分</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name stress1 -it --rm --cpu-shares 512 lorel/docker-stress-ng:latest --cpu 8</span><br><span class="line">docker run --name stress2 -it --rm --cpu-shares 512 lorel/docker-stress-ng:latest --cpu 8</span><br><span class="line">docker run --name stress3 -it --rm --cpu-shares 1024 lorel/docker-stress-ng:latest --cpu 8</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONTAINER ID     NAME          CPU %         MEM USAGE /  LIMIT     MEM %      NET I/O             BLOCK I/O           PIDS</span><br><span class="line">614274d03cc4     stress1       200.11%       22.65MiB  / 1.935GiB   1.14%      648B / 0B           0B / 0B             9</span><br><span class="line">1c737b7a56b9     stress2       201.12%       15.81MiB  / 1.935GiB   0.80%      648B / 0B           0B / 0B             9</span><br><span class="line">d8b52ba4567a     stress        426.07%       15.82MiB  / 1.935GiB   0.80%      648B / 0B           0B / 0B             9</span><br></pre></td></tr></table></figure>
<h2 id="资源监视"><a href="#资源监视" class="headerlink" title="资源监视"></a>资源监视</h2><ul>
<li>显示容器的运行进程</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container top stress</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UID        PID         PPID         C         STIME     TTY          TIME                CMD</span><br><span class="line">root       19220       19202        0         21:50     pts/0        00:00:00            /usr/bin/stress-ng --cpu 8</span><br><span class="line">root       19265       19220        99        21:50     pts/0        00:00:08            /usr/bin/stress-ng --cpu 8</span><br><span class="line">root       19266       19220        99        21:50     pts/0        00:00:08            /usr/bin/stress-ng --cpu 8</span><br><span class="line">root       19267       19220        99        21:50     pts/0        00:00:08            /usr/bin/stress-ng --cpu 8</span><br><span class="line">root       19268       19220        99        21:50     pts/0        00:00:08            /usr/bin/stress-ng --cpu 8</span><br><span class="line">root       19269       19220        99        21:50     pts/0        00:00:08            /usr/bin/stress-ng --cpu 8</span><br><span class="line">root       19270       19220        99        21:50     pts/0        00:00:08            /usr/bin/stress-ng --cpu 8</span><br><span class="line">root       19271       19220        99        21:50     pts/0        00:00:08            /usr/bin/stress-ng --cpu 8</span><br><span class="line">root       19272       19220        99        21:50     pts/0        00:00:08            /usr/bin/stress-ng --cpu 8</span><br></pre></td></tr></table></figure>
<ul>
<li>显示容器资源使用情况统计信息的实时流</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container stats [OPTIONS] [CONTAINER...]</span><br><span class="line"></span><br><span class="line">docker container stats</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONTAINER ID     NAME                 CPU %    MEM USAGE / LIMIT     MEM %     NET I/O             BLOCK I/O           PIDS</span><br><span class="line">e9cfd00dd136     harbor-jobservice    0.08%    8.227MiB / 1.935GiB   0.42%     270kB / 2.43MB      26.9MB / 0B         19</span><br><span class="line">0b8367c53e65     nginx                0.00%    5.293MiB / 1.935GiB   0.27%     61.1kB / 22.6kB     21.1MB / 0B         9</span><br><span class="line">e71810022898     harbor-ui            0.00%    7.777MiB / 1.935GiB   0.39%     123kB / 118kB       29.7MB / 0B         16</span><br><span class="line">8fb94f39f45c     registry             0.02%    6.254MiB / 1.935GiB   0.32%     6.18kB / 2.53kB     28.9MB / 0B         14</span><br><span class="line">016f887c4e22     harbor-adminserver   0.00%    5.207MiB / 1.935GiB   0.26%     182kB / 128kB       25.9MB / 0B         14</span><br><span class="line">b7fecac55ebe     harbor-db            0.03%    106.6MiB / 1.935GiB   5.38%     49.6kB / 169kB      55.7MB / 6.36MB     36</span><br><span class="line">3b196739335d     redis                0.12%    6.762MiB / 1.935GiB   0.34%     2.47MB / 277kB      18.6MB / 62kB       5</span><br><span class="line">f5667ad4c962     harbor-log           0.00%    1.953MiB / 1.935GiB   0.10%     83.1kB / 30.9kB     18.7MB / 8.19kB     11</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/09/personal/口腔溃疡/" rel="next" title="口腔溃疡愈合指南">
                <i class="fa fa-chevron-left"></i> 口腔溃疡愈合指南
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/10/Linux/mysql_install/" rel="prev" title="一个自动编译安装My-SQL的脚本">
                一个自动编译安装My-SQL的脚本 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jin Heng">
            
              <p class="site-author-name" itemprop="name">Jin Heng</p>
              <p class="site-description motion-element" itemprop="description">越努力越幸运</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yangjinheng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:jinhengyang@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          
        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#容器技术"><span class="nav-number">1.</span> <span class="nav-text">容器技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Cgroups"><span class="nav-number">1.1.</span> <span class="nav-text">Cgroups</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Namespaces"><span class="nav-number">1.2.</span> <span class="nav-text">Namespaces</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LXC"><span class="nav-number">1.3.</span> <span class="nav-text">LXC</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker简介"><span class="nav-number">2.</span> <span class="nav-text">Docker简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#runC"><span class="nav-number">2.1.</span> <span class="nav-text">runC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UnionFS"><span class="nav-number">2.2.</span> <span class="nav-text">UnionFS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Registry"><span class="nav-number">2.3.</span> <span class="nav-text">Registry</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Docker镜像"><span class="nav-number">3.</span> <span class="nav-text">Docker镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Base镜像"><span class="nav-number">3.1.</span> <span class="nav-text">Base镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜像组成"><span class="nav-number">3.2.</span> <span class="nav-text">镜像组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分层结构"><span class="nav-number">3.3.</span> <span class="nav-text">分层结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载过程"><span class="nav-number">3.4.</span> <span class="nav-text">加载过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写时复制"><span class="nav-number">3.5.</span> <span class="nav-text">写时复制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#入门使用"><span class="nav-number">4.</span> <span class="nav-text">入门使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#工作模式"><span class="nav-number">4.1.</span> <span class="nav-text">工作模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装部署"><span class="nav-number">4.2.</span> <span class="nav-text">安装部署</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜像管理"><span class="nav-number">4.3.</span> <span class="nav-text">镜像管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#启动一个容器"><span class="nav-number">4.4.</span> <span class="nav-text">启动一个容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连入运行中的容器"><span class="nav-number">4.5.</span> <span class="nav-text">连入运行中的容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器状态查看"><span class="nav-number">4.6.</span> <span class="nav-text">容器状态查看</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#推送镜像到仓库"><span class="nav-number">4.7.</span> <span class="nav-text">推送镜像到仓库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于容器制作镜像"><span class="nav-number">4.8.</span> <span class="nav-text">基于容器制作镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#镜像导入导出"><span class="nav-number">4.9.</span> <span class="nav-text">镜像导入导出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令大全"><span class="nav-number">4.10.</span> <span class="nav-text">命令大全</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络连接"><span class="nav-number">5.</span> <span class="nav-text">网络连接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#名称空间"><span class="nav-number">5.1.</span> <span class="nav-text">名称空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-网络模式"><span class="nav-number">5.2.</span> <span class="nav-text">Docker 网络模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义docker0"><span class="nav-number">5.3.</span> <span class="nav-text">自定义docker0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器相关命令"><span class="nav-number">5.4.</span> <span class="nav-text">容器相关命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定网络模式"><span class="nav-number">5.5.</span> <span class="nav-text">指定网络模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开放式容器"><span class="nav-number">5.6.</span> <span class="nav-text">开放式容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#联盟式网络"><span class="nav-number">5.7.</span> <span class="nav-text">联盟式网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器间互联"><span class="nav-number">5.8.</span> <span class="nav-text">容器间互联</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义网络"><span class="nav-number">5.9.</span> <span class="nav-text">自定义网络</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#端口映射"><span class="nav-number">5.10.</span> <span class="nav-text">端口映射</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#存储卷"><span class="nav-number">6.</span> <span class="nav-text">存储卷</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#卷的类型"><span class="nav-number">6.1.</span> <span class="nav-text">卷的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker管理卷"><span class="nav-number">6.2.</span> <span class="nav-text">Docker管理卷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定挂载卷"><span class="nav-number">6.3.</span> <span class="nav-text">绑定挂载卷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器共享卷"><span class="nav-number">6.4.</span> <span class="nav-text">容器共享卷</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dockerfile"><span class="nav-number">7.</span> <span class="nav-text">Dockerfile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#注意事项"><span class="nav-number">7.1.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建镜像"><span class="nav-number">7.2.</span> <span class="nav-text">构建镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FROM"><span class="nav-number">7.3.</span> <span class="nav-text">FROM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MAINTAINER"><span class="nav-number">7.4.</span> <span class="nav-text">MAINTAINER</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#COPY"><span class="nav-number">7.5.</span> <span class="nav-text">COPY</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ADD"><span class="nav-number">7.6.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WORKDIR"><span class="nav-number">7.7.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VOLUME"><span class="nav-number">7.8.</span> <span class="nav-text">VOLUME</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EXPOSE"><span class="nav-number">7.9.</span> <span class="nav-text">EXPOSE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ENV"><span class="nav-number">7.10.</span> <span class="nav-text">ENV</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RUN"><span class="nav-number">7.11.</span> <span class="nav-text">RUN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMD"><span class="nav-number">7.12.</span> <span class="nav-text">CMD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">7.13.</span> <span class="nav-text">ENTRYPOINT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#USER"><span class="nav-number">7.14.</span> <span class="nav-text">USER</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HEALTHCHECK"><span class="nav-number">7.15.</span> <span class="nav-text">HEALTHCHECK</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SHELL"><span class="nav-number">7.16.</span> <span class="nav-text">SHELL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STOPSIGNAL"><span class="nav-number">7.17.</span> <span class="nav-text">STOPSIGNAL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARG"><span class="nav-number">7.18.</span> <span class="nav-text">ARG</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ONBUILD"><span class="nav-number">7.19.</span> <span class="nav-text">ONBUILD</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自建仓库"><span class="nav-number">8.</span> <span class="nav-text">自建仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-Registry"><span class="nav-number">8.1.</span> <span class="nav-text">Docker-Registry</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装部署-1"><span class="nav-number">8.1.1.</span> <span class="nav-text">安装部署</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推送镜像"><span class="nav-number">8.1.2.</span> <span class="nav-text">推送镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Harbor"><span class="nav-number">8.2.</span> <span class="nav-text">Harbor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装配置"><span class="nav-number">8.2.1.</span> <span class="nav-text">安装配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动停止"><span class="nav-number">8.2.2.</span> <span class="nav-text">启动停止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建项目"><span class="nav-number">8.2.3.</span> <span class="nav-text">创建项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推送镜像-1"><span class="nav-number">8.2.4.</span> <span class="nav-text">推送镜像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#资源限制"><span class="nav-number">9.</span> <span class="nav-text">资源限制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存资源"><span class="nav-number">9.1.</span> <span class="nav-text">内存资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU限制"><span class="nav-number">9.2.</span> <span class="nav-text">CPU限制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源监视"><span class="nav-number">9.3.</span> <span class="nav-text">资源监视</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jin Heng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  













  





  

  

  

  
  

  

  

  

</body>
</html>
