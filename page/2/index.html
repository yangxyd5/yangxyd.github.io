<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="越努力越幸运">
<meta property="og:type" content="website">
<meta property="og:title" content="默默">
<meta property="og:url" content="https://yangjinheng.github.io/page/2/index.html">
<meta property="og:site_name" content="默默">
<meta property="og:description" content="越努力越幸运">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="默默">
<meta name="twitter:description" content="越努力越幸运">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yangjinheng.github.io/page/2/">





  <title>默默</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?be46574a10a6c2b7f67e9c32a008cbd5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">默默</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-前端知识">
          <a href="/categories/web/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-asterisk"></i> <br>
            
            前端知识
          </a>
        </li>
      
        
        <li class="menu-item menu-item-kubernetes">
          <a href="/categories/Kubernetes/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-cog"></i> <br>
            
            Kubernetes
          </a>
        </li>
      
        
        <li class="menu-item menu-item-运维笔记">
          <a href="/categories/运维笔记/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            运维笔记
          </a>
        </li>
      
        
        <li class="menu-item menu-item-python">
          <a href="/categories/Python/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-laptop"></i> <br>
            
            Python
          </a>
        </li>
      
        
        <li class="menu-item menu-item-golang">
          <a href="/categories/golang/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            Golang
          </a>
        </li>
      
        
        <li class="menu-item menu-item-个人日志">
          <a href="/categories/个人日志/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-github-alt"></i> <br>
            
            个人日志
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            给我留言
          </a>
        </li>
      

      
    </ul>
  

  
</nav>


 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangjinheng.github.io/2019/10/07/go/3.网络编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Heng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="默默">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/07/go/3.网络编程/" itemprop="url">网络编程基础和框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-07T00:00:00+08:00">
                2019-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index">
                    <span itemprop="name">golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>在标准库 net 包下提供了可一直的网络 I/O 接口，其中包含了 Socket</p>
<p>Socket 在 TCP/IP 网络分层中并不存在，它是对 TCP/UDP 的封装</p>
<ol>
<li>TCPAddr 结构体表示服务器 IP 和端口</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TCPAddr <span class="keyword">struct</span> &#123;</span><br><span class="line">    IP IP</span><br><span class="line">    Port <span class="keyword">int</span></span><br><span class="line">    Zone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>TCPConn 结构体表示连接，封装了数据读写操作</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TCPConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	conn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>TCPListener 负责监听服务器端特定端口</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TCPListener <span class="keyword">struct</span> &#123;</span><br><span class="line">    fd *netFD</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回显服务器"><a href="#回显服务器" class="headerlink" title="回显服务器"></a>回显服务器</h2><ul>
<li>server</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建 TCPAddress 变量，指向协议 TCP4，监听本机的一个端口</span></span><br><span class="line">	addr, _ := net.ResolveTCPAddr(<span class="string">"tcp4"</span>, <span class="string">"localhost:8000"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听 TCPAddress 设定的地址</span></span><br><span class="line">	lis, _ := net.ListenTCP(<span class="string">"tcp4"</span>, addr)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"服务器已经启动"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器接收和建立连接是不间断的</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 阻塞时等待客户端消息，返回连接对象，用于接收客户端消息或向客户端发送消息</span></span><br><span class="line">		conn, _ := lis.Accept()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 把数据读取到切片中</span></span><br><span class="line">		b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">256</span>)</span><br><span class="line">		fmt.Println(<span class="string">"read之前"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 客户端没有发送数据且客户端对象没有关闭，Read() 将会阻塞，一旦接收到数据就不阻塞</span></span><br><span class="line">		count, _ := conn.Read(b)</span><br><span class="line">		fmt.Println(<span class="string">"接收到数据:"</span>, <span class="keyword">string</span>(b[:count]))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 向客户端返回一个消息</span></span><br><span class="line">		conn.Write([]<span class="keyword">byte</span>(<span class="string">"server"</span> + <span class="keyword">string</span>(b[:count])))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关闭连接</span></span><br><span class="line">		conn.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"服务器停止运行"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>client</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建服务器端地址</span></span><br><span class="line">	addr, _ := net.ResolveTCPAddr(<span class="string">"tcp4"</span>, <span class="string">"localhost:8000"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建连接</span></span><br><span class="line">	conn, _ := net.DialTCP(<span class="string">"tcp"</span>, <span class="literal">nil</span>, addr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发送数据</span></span><br><span class="line">	conn.Write([]<span class="keyword">byte</span>(<span class="string">"客户端发送的数据"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接收数据</span></span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">256</span>)</span><br><span class="line">	fmt.Println(<span class="string">"read之前"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接收数据</span></span><br><span class="line">	count, _ := conn.Read(b)</span><br><span class="line">	fmt.Println(<span class="string">"接收到数据:"</span>, <span class="keyword">string</span>(b[:count]))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭连接</span></span><br><span class="line">	conn.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发回显服务器"><a href="#并发回显服务器" class="headerlink" title="并发回显服务器"></a>并发回显服务器</h2><ul>
<li>server，使用 goroutine 接收处理每个请求</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建 TCPAddress 变量，指向协议 TCP4，监听本机的一个端口</span></span><br><span class="line">	addr, _ := net.ResolveTCPAddr(<span class="string">"tcp4"</span>, <span class="string">"localhost:8000"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 监听 TCPAddress 设定的地址</span></span><br><span class="line">	lis, _ := net.ListenTCP(<span class="string">"tcp4"</span>, addr)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"服务器已经启动"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器接收和建立连接是不间断的</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 阻塞时等待客户端消息，返回连接对象，用于接收客户端消息或向客户端发送消息</span></span><br><span class="line">		conn, _ := lis.Accept()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 添加 goroutine 让服务器支持并发</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 把数据读取到切片中</span></span><br><span class="line">			b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">256</span>)</span><br><span class="line">			fmt.Println(<span class="string">"read之前"</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 有意延迟</span></span><br><span class="line">			time.Sleep(<span class="number">2e9</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 客户端没有发送数据且客户端对象没有关闭，Read() 将会阻塞，一旦接收到数据就不阻塞</span></span><br><span class="line">			count, _ := conn.Read(b)</span><br><span class="line">			fmt.Println(<span class="string">"接收到数据:"</span>, <span class="keyword">string</span>(b[:count]))</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 向客户端返回一个消息</span></span><br><span class="line">			conn.Write([]<span class="keyword">byte</span>(<span class="string">"server"</span> + <span class="keyword">string</span>(b[:count])))</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 关闭连接</span></span><br><span class="line">			conn.Close()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"服务器停止运行"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>client，使用 go route 模拟同时发送 10 个请求</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建服务器端地址</span></span><br><span class="line">	addr, _ := net.ResolveTCPAddr(<span class="string">"tcp4"</span>, <span class="string">"localhost:8000"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// 创建连接</span></span><br><span class="line">			conn, _ := net.DialTCP(<span class="string">"tcp"</span>, <span class="literal">nil</span>, addr)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 发送数据</span></span><br><span class="line">			conn.Write([]<span class="keyword">byte</span>(<span class="string">"客户端发送的数据"</span>))</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 接收数据</span></span><br><span class="line">			b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 接收数据</span></span><br><span class="line">			count, _ := conn.Read(b)</span><br><span class="line">			fmt.Println(<span class="string">"接收到数据:"</span>, <span class="keyword">string</span>(b[:count]))</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 关闭连接</span></span><br><span class="line">			conn.Close()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">3e9</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="点对点通信"><a href="#点对点通信" class="headerlink" title="点对点通信"></a>点对点通信</h2><p>点对点通信是一个客户端与客户端的通信</p>
<ul>
<li>server</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Username  <span class="keyword">string</span></span><br><span class="line">	OtherUser <span class="keyword">string</span></span><br><span class="line">	Msg       <span class="keyword">string</span></span><br><span class="line">	ServerMsg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	usermap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]net.Conn)</span><br><span class="line">	user    = <span class="built_in">new</span>(User)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	addr, _ := net.ResolveTCPAddr(<span class="string">"tcp4"</span>, <span class="string">"127.0.0.1:8000"</span>)</span><br><span class="line">	lis, _ := net.ListenTCP(<span class="string">"tcp4"</span>, addr)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, _ := lis.Accept()</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">				count, _ := conn.Read(b)</span><br><span class="line">				array := strings.Split(<span class="keyword">string</span>(b[:count]), <span class="string">"-"</span>)</span><br><span class="line">				user.Username = array[<span class="number">0</span>]</span><br><span class="line">				user.OtherUser = array[<span class="number">1</span>]</span><br><span class="line">				user.Msg = array[<span class="number">2</span>]</span><br><span class="line">				user.ServerMsg = array[<span class="number">3</span>]</span><br><span class="line">				usermap[user.Username]=conn</span><br><span class="line">				<span class="keyword">if</span> v, ok := usermap[user.OtherUser]; ok &amp;&amp; v != <span class="literal">nil</span> &#123;</span><br><span class="line">					message := fmt.Sprintf(<span class="string">"%s-%s-%s-%s"</span>, user.Username, user.OtherUser, user.Msg, user.ServerMsg)</span><br><span class="line">					n, err := v.Write([]<span class="keyword">byte</span>(message))</span><br><span class="line">					<span class="keyword">if</span> n &lt;= <span class="number">0</span> || err != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="built_in">delete</span>(usermap, user.OtherUser)</span><br><span class="line">						conn.Close()</span><br><span class="line">						v.Close()</span><br><span class="line">						<span class="keyword">break</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					user.ServerMsg = <span class="string">"对方不在线"</span></span><br><span class="line">					message := fmt.Sprintf(<span class="string">"%s-%s-%s-%s"</span>, user.Username, user.OtherUser, user.Msg, user.ServerMsg)</span><br><span class="line">					conn.Write([]<span class="keyword">byte</span>(message))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>client</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Username      <span class="keyword">string</span></span><br><span class="line">	OtherUsername <span class="keyword">string</span></span><br><span class="line">	Msg           <span class="keyword">string</span></span><br><span class="line">	ServerMsg     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	user = <span class="built_in">new</span>(User)</span><br><span class="line">	wg   sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"请输入您的账号:"</span>)</span><br><span class="line">	fmt.Scanln(&amp;user.Username)</span><br><span class="line">	fmt.Println(<span class="string">"请输入要给谁发送消息:"</span>)</span><br><span class="line">	fmt.Scanln(&amp;user.OtherUsername)</span><br><span class="line"></span><br><span class="line">	addr, _ := net.ResolveTCPAddr(<span class="string">"tcp4"</span>, <span class="string">"127.0.0.1:8000"</span>)</span><br><span class="line">	conn, _ := net.DialTCP(<span class="string">"tcp4"</span>, <span class="literal">nil</span>, addr)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"请输入要发送的信息，本提示仅一次，以后直接输入"</span>)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			fmt.Scanln(&amp;user.Msg)</span><br><span class="line">			<span class="keyword">if</span> user.Msg == <span class="string">"exit"</span> &#123;</span><br><span class="line">				conn.Close()</span><br><span class="line">				wg.Done()</span><br><span class="line">				os.Exit(<span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			message := fmt.Sprintf(<span class="string">"%s-%s-%s-%s"</span>, user.Username, user.OtherUsername, user.Msg, user.ServerMsg)</span><br><span class="line">			conn.Write([]<span class="keyword">byte</span>(message))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">			count, _ := conn.Read(b)</span><br><span class="line">			array := strings.Split(<span class="keyword">string</span>(b[:count]), <span class="string">"-"</span>)</span><br><span class="line">			user2 := <span class="built_in">new</span>(User)</span><br><span class="line">			user2.Username = array[<span class="number">0</span>]</span><br><span class="line">			user2.OtherUsername = array[<span class="number">1</span>]</span><br><span class="line">			user2.Msg = array[<span class="number">2</span>]</span><br><span class="line">			user2.ServerMsg = array[<span class="number">3</span>]</span><br><span class="line">			<span class="keyword">if</span> user2.ServerMsg != <span class="string">""</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">"\t服务器的消息"</span>, user2.ServerMsg)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">"\t"</span>, user2.Username, <span class="string">":"</span>, user2.Msg)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="http-服务器"><a href="#http-服务器" class="headerlink" title="http 服务器"></a>http 服务器</h1><ol>
<li>HandleFunc 可以设置函数的请求路径</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern</span></span><br><span class="line"><span class="comment">// in the DefaultServeMux.</span></span><br><span class="line"><span class="comment">// The documentation for ServeMux explains how patterns are matched.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>ListenAndServe 实现了监听服务</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListenAndServe always returns a non-nil error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">	<span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个 Go web 项目</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">welcome</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/html;charset=utf-8"</span>)</span><br><span class="line">	fmt.Fprint(w, <span class="string">"&lt;h1&gt;服务器返回的信息&lt;/h1&gt;"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, welcome)</span><br><span class="line">	http.ListenAndServe(<span class="string">"127.0.0.1:8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单控制器"><a href="#单控制器" class="headerlink" title="单控制器"></a>单控制器</h2><p>在 Go 语言的 net/http 包下有 ServeMux 实现了 Front 设计模式的 Front 窗口，ServeMux 负责接收请求并把请求分发给处理器（Handler）</p>
<ol>
<li>Http.ServeMux 源码实现了 Handler 接口</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;                     <span class="comment">// 处理一个请求的处理器</span></span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;                      <span class="comment">// ServeMux 结构体</span></span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">	es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">	hosts <span class="keyword">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServeMux 结构体重写了 ServeHTTP 这个方法，就是 ServeMux 结构体实现了 ServeHTTP 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">			w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h, _ := mux.Handler(r)</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义结构体，实现 Handler 接口后，这个结构体就属于一个处理器，可以处理请求</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Myhandeler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *Myhandeler)</span> <span class="title">ServeHTTP</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintln(res, <span class="string">"输出内容"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myhandeler := Myhandeler&#123;&#125;</span><br><span class="line">	server := http.Server&#123;</span><br><span class="line">		Addr:    <span class="string">"127.0.0.1:8090"</span>,</span><br><span class="line">		Handler: &amp;myhandeler,</span><br><span class="line">	&#125;</span><br><span class="line">	server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多控制器"><a href="#多控制器" class="headerlink" title="多控制器"></a>多控制器</h2><p>在实际开发中，必须有多个控制器，来区分业务，Go 语言中支持两种处理方式</p>
<ol>
<li>多个处理器（Handler）</li>
<li>多个处理函数（HandleFunc）</li>
</ol>
<h3 id="使用多处理器"><a href="#使用多处理器" class="headerlink" title="使用多处理器"></a>使用多处理器</h3><p>使用 Http.Handler 把不同的 URL 绑定到不同的处理器，在浏览器输入：/myhandler 或者 /myother 可以访问两个处理器，访问其他出现 404</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Myhandeler <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Myother <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *Myhandeler)</span> <span class="title">ServeHTTP</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	res.Write([]<span class="keyword">byte</span>(<span class="string">"&lt;h1&gt;Myhandeler 输出内容&lt;/h1&gt;"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mh *Myother)</span> <span class="title">ServeHTTP</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	res.Write([]<span class="keyword">byte</span>(<span class="string">"&lt;h1&gt;Myother 输出内容&lt;/h1&gt;"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myhandeler := Myhandeler&#123;&#125;</span><br><span class="line">	myother := Myother&#123;&#125;</span><br><span class="line">	server := http.Server&#123;Addr: <span class="string">"127.0.0.1:8080"</span>&#125;</span><br><span class="line">	http.Handle(<span class="string">"/myhandler"</span>, &amp;myhandeler)</span><br><span class="line">	http.Handle(<span class="string">"/myother"</span>, &amp;myother)</span><br><span class="line">	server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多处理器函数"><a href="#多处理器函数" class="headerlink" title="多处理器函数"></a>多处理器函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myhandler</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	res.Write([]<span class="keyword">byte</span>(<span class="string">"&lt;h1&gt;Myhandeler 输出内容&lt;/h1&gt;"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myother</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	res.Write([]<span class="keyword">byte</span>(<span class="string">"&lt;h1&gt;Myother 输出内容&lt;/h1&gt;"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server := http.Server&#123;Addr: <span class="string">"127.0.0.1:8080"</span>&#125;</span><br><span class="line">	http.HandleFunc(<span class="string">"/myhandler"</span>, myhandler)</span><br><span class="line">	http.HandleFunc(<span class="string">"/myother"</span>, myother)</span><br><span class="line">	server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取请求头和参数"><a href="#获取请求头和参数" class="headerlink" title="获取请求头和参数"></a>获取请求头和参数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置响应头</span></span><br><span class="line">	res.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"text/html;charset=utf-8"</span>)</span><br><span class="line"></span><br><span class="line">	res.Write([]<span class="keyword">byte</span>(<span class="string">"&lt;h3&gt;请求头的信息&lt;/h3&gt;"</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 请求头</span></span><br><span class="line">	header := req.Header</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> header &#123;</span><br><span class="line">		key := []<span class="keyword">byte</span>(k)</span><br><span class="line">		res.Write(key)</span><br><span class="line">		res.Write([]<span class="keyword">byte</span>(<span class="string">" -&gt; "</span>))</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> v &#123;</span><br><span class="line">			res.Write([]<span class="keyword">byte</span>(v))</span><br><span class="line">			res.Write([]<span class="keyword">byte</span>(<span class="string">"&amp;nbsp;"</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		res.Write([]<span class="keyword">byte</span>(<span class="string">"&lt;/br&gt;"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res.Write([]<span class="keyword">byte</span>(<span class="string">"&lt;h3&gt;请求参数的信息&lt;/h3&gt;"</span>))</span><br><span class="line">	<span class="comment">// 请求参数</span></span><br><span class="line">	req.ParseForm()</span><br><span class="line">	form := req.Form</span><br><span class="line">	<span class="keyword">for</span> k, _ := <span class="keyword">range</span> form &#123;</span><br><span class="line">		key := []<span class="keyword">byte</span>(k)</span><br><span class="line">		res.Write(key)</span><br><span class="line">		res.Write([]<span class="keyword">byte</span>(<span class="string">" -&gt; "</span>))</span><br><span class="line">		res.Write([]<span class="keyword">byte</span>(req.FormValue(k)))</span><br><span class="line">		<span class="comment">// for _, v := range v &#123;</span></span><br><span class="line">		<span class="comment">// 	res.Write([]byte(v))</span></span><br><span class="line">		<span class="comment">// 	res.Write([]byte("&amp;nbsp;"))</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">		res.Write([]<span class="keyword">byte</span>(<span class="string">"&lt;/br&gt;"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server := http.Server&#123;Addr: <span class="string">"127.0.0.1:8080"</span>&#125;</span><br><span class="line">	http.HandleFunc(<span class="string">"/handler"</span>, handler)</span><br><span class="line">	server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><ul>
<li>站点的文件组织</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">web/</span><br><span class="line">├── main.<span class="keyword">go</span>                              <span class="comment">// main 函数</span></span><br><span class="line">├── src                                  <span class="comment">// go 源码文件</span></span><br><span class="line">├── static                               <span class="comment">// 静态文件资源</span></span><br><span class="line">│   ├── css</span><br><span class="line">│   ├── images</span><br><span class="line">│   └── js</span><br><span class="line">│       └── main.js</span><br><span class="line">└── templates                            <span class="comment">// 模板文件目录</span></span><br><span class="line">    └── index.html</span><br></pre></td></tr></table></figure>
<h2 id="html-模板"><a href="#html-模板" class="headerlink" title="html 模板"></a>html 模板</h2><ul>
<li>静态文件：static/js/main.js</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">button = <span class="built_in">document</span>.querySelector(<span class="string">".button"</span>);</span><br><span class="line"></span><br><span class="line">button.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"点击了按钮"</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>模板文件：templates/index.html</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h2&gt;Hello Golang&lt;/h2&gt;</span><br><span class="line">    &lt;input <span class="keyword">type</span>=<span class="string">"button"</span> value=<span class="string">"æŒ‰é’®"</span> class=<span class="string">"button"</span>/&gt;</span><br><span class="line">    &lt;script src="/static/js/main.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>main.go</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"html/template"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	t, _ := template.ParseFiles(<span class="string">"templates/index.html"</span>)</span><br><span class="line">	t.Execute(res, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server := http.Server&#123;Addr: <span class="string">"127.0.0.1:8080"</span>&#125;</span><br><span class="line">	<span class="comment">// 让静态文件服务生效</span></span><br><span class="line">	http.Handle(<span class="string">"/static/"</span>, http.StripPrefix(<span class="string">"/static/"</span>, http.FileServer(http.Dir(<span class="string">"static"</span>))))</span><br><span class="line">	http.HandleFunc(<span class="string">"/handler"</span>, handler)</span><br><span class="line">	server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单的-HTTP-文件服务器"><a href="#简单的-HTTP-文件服务器" class="headerlink" title="简单的 HTTP 文件服务器"></a>简单的 HTTP 文件服务器</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">        <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        server := http.Server&#123;Addr: <span class="string">":80"</span>&#125;</span><br><span class="line">        http.Handle(<span class="string">"/"</span>, http.FileServer(http.Dir(os.Args[<span class="number">1</span>])))</span><br><span class="line">        server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h1><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><table>
<thead>
<tr>
<th>头信息</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>exctype=”application/x-www-form-urlencoded”</td>
<td>默认值。表单会被编码为键=值&amp;</td>
</tr>
<tr>
<td>exctype=”multipart/form-data”</td>
<td>编码成消息，每个控件对应消息的一部分，请求方式必须是 POST，它可以上传文件和表单</td>
</tr>
<tr>
<td>exctype=”text/plain”</td>
<td>纯文本形式编码</td>
</tr>
</tbody>
</table>
<ul>
<li>HTML</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;/upload&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    名称：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;</span><br><span class="line">    文件：&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>后端代码</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"html/template"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">upload</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	username := req.FormValue(<span class="string">"name"</span>)</span><br><span class="line">	file, header, _ := req.FormFile(<span class="string">"file"</span>)</span><br><span class="line">	b, _ := ioutil.ReadAll(file)</span><br><span class="line">	ioutil.WriteFile(<span class="string">"D:/"</span>+header.Filename, b, <span class="number">0777</span>)</span><br><span class="line">	res.Write([]<span class="keyword">byte</span>(username + <span class="string">"上传成功"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	t, _ := template.ParseFiles(<span class="string">"templates/index.html"</span>)</span><br><span class="line">	t.Execute(res, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server := http.Server&#123;Addr: <span class="string">"127.0.0.1:8080"</span>&#125;</span><br><span class="line">	http.Handle(<span class="string">"/static/"</span>, http.StripPrefix(<span class="string">"/static/"</span>, http.FileServer(http.Dir(<span class="string">"static"</span>))))</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">	http.HandleFunc(<span class="string">"/upload"</span>, upload)</span><br><span class="line">	server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><p>客户端下载文件时候，服务器需要设置的响应头信息：</p>
<ol>
<li>Content-Type: 内容的 MIME 类型</li>
</ol>
<p>application/octet-stream 任意类型</p>
<ol start="2">
<li>Content-Disposition: 客户端对内容的操作方式</li>
</ol>
<p>inline 默认值，表示浏览器能解析就解析，不能解析就下载</p>
<p>attachment;filename=下载时显示的文件名，客户端始终会下载文件</p>
<ul>
<li>html 代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/download?filename=abc.jpg"</span>&gt;</span>下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>后端代码</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"html/template"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">download</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	filename := req.FormValue(<span class="string">"filename"</span>)</span><br><span class="line">	f, err := ioutil.ReadFile(<span class="string">"D:/"</span> + filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		res.Write([]<span class="keyword">byte</span>(<span class="string">"下载失败"</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	res.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>)</span><br><span class="line">	res.Header().Set(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;filename="</span>+filename)</span><br><span class="line">	res.Write(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">	t, _ := template.ParseFiles(<span class="string">"templates/index.html"</span>)</span><br><span class="line">	t.Execute(res, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server := http.Server&#123;Addr: <span class="string">"127.0.0.1:8080"</span>&#125;</span><br><span class="line">	http.Handle(<span class="string">"/static/"</span>, http.StripPrefix(<span class="string">"/static/"</span>, http.FileServer(http.Dir(<span class="string">"static"</span>))))</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, handler)</span><br><span class="line">	http.HandleFunc(<span class="string">"/download"</span>, download)</span><br><span class="line">	server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"fullname"`</span></span><br><span class="line">	Age  <span class="keyword">int</span>    <span class="string">`json:"age"`</span></span><br><span class="line">	Sex  <span class="keyword">string</span> <span class="string">`json:"gender"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yangjinheng.github.io/2019/07/20/go/2.函数和结构体/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jin Heng">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="默默">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/20/go/2.函数和结构体/" itemprop="url">函数结构体和面向对象和并发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-20T00:00:00+08:00">
                2019-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index">
                    <span itemprop="name">golang</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul>
<li>声明语法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span> 返回值</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用语法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">返回值 := 函数名(参数)</span><br></pre></td></tr></table></figure>
<h2 id="无参数无返回值函数"><a href="#无参数无返回值函数" class="headerlink" title="无参数无返回值函数"></a>无参数无返回值函数</h2><ul>
<li>无返回值的函数相当于一个过程，它不回给调用者返回结果</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	demo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"执行了demo函数"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有参函数有返回值"><a href="#有参函数有返回值" class="headerlink" title="有参函数有返回值"></a>有参函数有返回值</h2><ol>
<li><p>函数的参数可以有多个，且每个参数类型都可以不同，参数可以在函数中使用</p>
</li>
<li><p>有返回值的函数可以给调用者返回数据，而不是一个无返回值的执行过程</p>
</li>
<li>声明函数时候可以声明一个返回值变量，在函数中就可以直接使用，并默认返回它</li>
</ol>
<ul>
<li>定义一个默认的返回值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	res = a + b</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多返回值函数"><a href="#多返回值函数" class="headerlink" title="多返回值函数"></a>多返回值函数</h2><p>Go 语言可以定义一个函数拥有多个返回值，Go 语言中所有的错误都是通过返回值的形式返回的。</p>
<p>理论上函数返回值个数可以无限多个，但是一般不这样定义，而使用结构体代替多返回值。</p>
<ul>
<li>多返回值函数的语法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数名<span class="params">(参数列表)</span> <span class="params">(返回值,返回值)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用函数的语法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">变量,变量 := 函数名(参数)</span><br></pre></td></tr></table></figure>
<ul>
<li>调用函数时如果不想接收可以使用 _ 来占位</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">变量,_ := 函数名(参数)</span><br></pre></td></tr></table></figure>
<ol>
<li>多返回值代码示例</li>
</ol>
<p>函数的返回值可以不接收，表示执行函数，但如果接收则必须与返回值的个数相同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c, d := show(<span class="string">"yangjinheng"</span>, <span class="number">30</span>)</span><br><span class="line">	fmt.Println(c, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func show(name string, age int) (string, int) &#123;</span></span><br><span class="line"><span class="comment">//     return name, age</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> <span class="params">(rname <span class="keyword">string</span>, rage <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	rname = name</span><br><span class="line">	rage = age</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">yangjinheng <span class="number">30</span></span><br></pre></td></tr></table></figure>
<h2 id="可变参数函数"><a href="#可变参数函数" class="headerlink" title="可变参数函数"></a>可变参数函数</h2><p>可变参数指的是调用参数时传递从参数个数可以是任意个，需要注意可变参数必须在参数列表的最后位置。</p>
<p>在参数名和类型之间添加三个点表示可变参数函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> 函数<span class="params">(参数,参数,参数 ...类型)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出语句就是可变参数函数，源码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Fprintln(os.Stdout, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>可变参数代码示例</li>
</ol>
<p>声明函数时，在函数体可以把可变参数当作切片使用即可</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	show(<span class="string">"zhao"</span>, <span class="string">"qian"</span>, <span class="string">"sun"</span>, <span class="string">"li"</span>, <span class="string">"zhou"</span>, <span class="string">"wu"</span>, <span class="string">"zheng"</span>, <span class="string">"wang"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(xing ...<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> a, b := <span class="keyword">range</span> xing &#123;</span><br><span class="line">		fmt.Println(a, b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> zhao</span><br><span class="line"><span class="number">1</span> qian</span><br><span class="line"><span class="number">2</span> sun</span><br><span class="line"><span class="number">3</span> li</span><br><span class="line"><span class="number">4</span> zhou</span><br><span class="line"><span class="number">5</span> wu</span><br><span class="line"><span class="number">6</span> zheng</span><br><span class="line"><span class="number">7</span> wang</span><br></pre></td></tr></table></figure>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数就是没有名称的函数，一般定义完就会立即调用，它总是定义在函数内部，定义格式：</p>
<ul>
<li>有参数的匿名函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(参数)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;(参数)</span><br></pre></td></tr></table></figure>
<ul>
<li>有参数有返回值的匿名函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        fmt.Println(s, <span class="string">"这是匿名函数"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">110</span></span><br><span class="line">    &#125;(<span class="string">"传递参数"</span>)</span><br><span class="line">    fmt.Println(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h2><p>在 Go 语言中函数也是一种类型，函数有多少种形式，函数变量就有多少种写法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">()</span>                  // 无参无返回值</span></span><br><span class="line"><span class="keyword">var</span> b <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span>               // 有一个 <span class="title">int</span> 类型参数</span></span><br><span class="line"><span class="keyword">var</span> c <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">string</span>        // 一个有 <span class="title">int</span> 类型参数和 <span class="title">string</span> 类型返回值</span></span><br><span class="line">fmt.Println(a,b,c)            <span class="comment">// 输出：&lt;nil&gt; &lt;nil&gt; &lt;nil&gt;</span></span><br></pre></td></tr></table></figure>
<p>定义完函数变量后，可以使用匿名函数进行赋值，也可以使用已经定义好的函数进行赋值，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	a = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"执行函数"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	a()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">执行函数</span><br></pre></td></tr></table></figure>
<p>函数变量定义后，与普通函数调用方式相同，变量名即是函数名。</p>
<p>函数类型变量是除了 slice、map、channel、interface 外的第五种引用类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	a = b</span><br><span class="line">	a()</span><br><span class="line">	<span class="keyword">var</span> c <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	c = a</span><br><span class="line">	c()</span><br><span class="line">	fmt.Printf(<span class="string">"%p %p"</span>, a, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"执行B函数"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">执行B函数</span><br><span class="line">执行B函数</span><br><span class="line"><span class="number">0x498850</span> <span class="number">0x498850</span></span><br></pre></td></tr></table></figure>
<h2 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h2><p>变量可以作为函数的参数或返回值，而函数变量也可以当作函数的参数或返回值，函数作为参数时，类型写为对应类型即可，例如：循环链表 ring 的 Do 方法它接收一个函数作为参数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化一个 5 个元素的链表，这个初始化的元素代表整个链表，也代表第一个元素</span></span><br><span class="line">	r := ring.New(<span class="number">5</span>)</span><br><span class="line">	r.Value = <span class="number">0</span></span><br><span class="line">	r.Next().Value = <span class="number">1</span></span><br><span class="line">	r.Next().Next().Value = <span class="number">2</span></span><br><span class="line">	r.Prev().Value = <span class="number">4</span></span><br><span class="line">	r.Prev().Prev().Value = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 循环链表有几个元素，func 就执行几次</span></span><br><span class="line">	r.Do(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要自己实现一个这样的功能，那么就可以这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">(fn <span class="keyword">func</span>(name <span class="keyword">string</span>)</span>)</span> &#123;   <span class="comment">// 声明一个函数，它接收一个函数作为参数</span></span><br><span class="line">	fn(<span class="string">"yangjinheng"</span>)             <span class="comment">// 调用接收到的函数，并为函数传递参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	do(<span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;        <span class="comment">// 调用函数，并传递一个匿名函数作为参数</span></span><br><span class="line">		fmt.Println(name)         <span class="comment">// 在函数内处理接收到的变量</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;           <span class="comment">// 声明一个函数，它返回一个函数 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;          <span class="comment">// 返回一个函数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1024</span>              <span class="comment">// 这个函数返回一个整数</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	def := fn()                  <span class="comment">// 调用函数，得到一个另外一个函数</span></span><br><span class="line">	result := def()              <span class="comment">// 调用得到的函数，得到结果</span></span><br><span class="line">	fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h1><p>变量作用域决定了变量可以访问的访问，Go 语言中变量的有效范围如下：</p>
<ol>
<li>局部变量：声明在函数内部的，只有函数内部可以访问的变量</li>
<li>全局变量：声明在函数外部的，可以在整个 package 中访问</li>
<li>应用级别：首字母大写的全局变量，可以跨 package 访问</li>
</ol>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>一般使用声明在函数内部的变量，它只能在函数内部被访问。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">2</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        j := <span class="number">3</span></span><br><span class="line">		fmt.Println(i + j)            <span class="comment">// i 可以在函数内部被访问</span></span><br><span class="line">	&#125;()</span><br><span class="line">    <span class="comment">// fmt.Println(i + j)             // 不可以访问 j 因为 j 属于匿名函数内的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func test2() &#123;</span></span><br><span class="line"><span class="comment">// 	fmt.Println(i)               // i 属于 test1 的局部变量，不能在其他函数内访问</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	name = <span class="string">"yangjinheng"</span></span><br><span class="line">	age  = <span class="number">30</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包就是解决局部变量不能被外部访问的一种解决方案</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	fn := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		i = i + <span class="number">1</span>                                     <span class="comment">// 在匿名函数内部访问父函数的变量，这就是闭包</span></span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"我是 test 的 i %p, %d\n"</span>, &amp;i, i)       <span class="comment">// 匿名函数对闭包中的变量修改，是创建了新的局部变量，而不是真的修改了父函数的变量 </span></span><br><span class="line">	<span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f1 := test()</span><br><span class="line">	s1 := f1()</span><br><span class="line">	fmt.Printf(<span class="string">"我是匿名函数的 i %p, %d\n"</span>, &amp;s1, s1)</span><br><span class="line"></span><br><span class="line">	f2 := test()</span><br><span class="line">	s2 := f2()</span><br><span class="line">	fmt.Printf(<span class="string">"我是匿名函数的 i %p, %d\n"</span>, &amp;s2, s2)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"我是匿名函数 %p %p"</span>, f1, f2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">父函数的 i 内存地址为: <span class="number">0xc000080090</span> 值: <span class="number">0</span>    <span class="comment">// 结论：1. 父函数 i 实际没有被修改</span></span><br><span class="line">匿名函数 i 内存地址为: <span class="number">0xc000080098</span> 值: <span class="number">1</span>    <span class="comment">// 结论：1. 匿名函数访问到了父函数的 i 产生了闭包，2. 匿名函数 i 是新创建的</span></span><br><span class="line">父函数的 i 内存地址为: <span class="number">0xc0000800b8</span> 值: <span class="number">0</span>    <span class="comment">// 结论：1. 父函数 i 实际没有被修改，2. 每次调用父函数 i 的地址都是不同的</span></span><br><span class="line">匿名函数 i 内存地址为: <span class="number">0xc0000800c0</span> 值: <span class="number">1</span>    <span class="comment">// 结论：1. 匿名函数访问到了父函数的 i 产生了闭包，2. 匿名函数 i 是新创建的，3. 每个匿名函数的 i 都是不同的地址，不会互相影响</span></span><br><span class="line">匿名函数 f1 内存地址为: <span class="number">0x4b95d0</span> 匿名函数 f2 内存地址为: <span class="number">0x4b95d0</span>  <span class="comment">// 结论：1. 每次调用父函数返回的匿名函数都是相同的内存地址，2. 每个匿名函数都有自己的栈</span></span><br></pre></td></tr></table></figure>
<h1 id="值类型引用类型传参"><a href="#值类型引用类型传参" class="headerlink" title="值类型引用类型传参"></a>值类型引用类型传参</h1><p>讨论值传递和引用传递时，我们讨论的是值类型变量和引用类型变量作为函数参数时，修改形参，是否影响到实参。</p>
<ol>
<li>在 Go 语言中有五个引用类型变量，其他都是值类型</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice、<span class="keyword">map</span>、channel、<span class="keyword">interface</span>、<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>引用类型作为参数时，称为浅拷贝，形参改变，实参跟随变化，因为传递的地址，形参和实参指向同一块内存地址</li>
<li>值类型作为参数时，称为深拷贝，形参改变，实参不变，因为传递的是值的副本，副本会开辟新的内存空间，形参和实参指向不同的内存地址</li>
<li>如果希望值类型数据在修改形参实参跟随变化，可以把参数设置为指针类型</li>
</ol>
<h2 id="值类型传参"><a href="#值类型传参" class="headerlink" title="值类型传参"></a>值类型传参</h2><ul>
<li>传递值类型时，对形参的修改，不会影响原来的实参，因为传递的是值的副本</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	name = <span class="string">"yangjinheng"</span></span><br><span class="line">	age  = <span class="number">30</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test(name, age)</span><br><span class="line">	fmt.Println(name, age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	name = <span class="string">"yangzhongxiao"</span></span><br><span class="line">	age = <span class="number">27</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">yangjinheng <span class="number">30</span></span><br></pre></td></tr></table></figure>
<h2 id="引用类型传参"><a href="#引用类型传参" class="headerlink" title="引用类型传参"></a>引用类型传参</h2><ul>
<li>传递引用类型时，对形参的修改，影响到了实参，因为形参和实参使用了相同的内存地址</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	names = []<span class="keyword">string</span>&#123;<span class="string">"yangjinheng"</span>, <span class="string">"yangzhongxiao"</span>&#125;</span><br><span class="line">	ages  = []<span class="keyword">int</span>&#123;<span class="number">30</span>, <span class="number">27</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test(names, ages)</span><br><span class="line">	fmt.Println(names, ages)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(names []<span class="keyword">string</span>, age []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	names[<span class="number">0</span>] = <span class="string">"yangdage"</span></span><br><span class="line">	ages[<span class="number">0</span>] = <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[yangdage yangzhongxiao] [<span class="number">18</span> <span class="number">27</span>]</span><br></pre></td></tr></table></figure>
<h2 id="指针类型形参"><a href="#指针类型形参" class="headerlink" title="指针类型形参"></a>指针类型形参</h2><ul>
<li>传参为指针类型时，对形参的修改，会影响到实参，因为形参和实参使用相同内存地址</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	addr  = <span class="string">"beijing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test(&amp;addr)</span><br><span class="line">	fmt.Println(addr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(addr *<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	*addr = <span class="string">"xian"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ol>
<li>将一个或多个变量组合到一起，形成新的类型，这个类型就是结构体</li>
<li>Go 语言中的结构体和 C++ 中的结构体有点类似，而 Java 或 C# 类本质就是结构体</li>
<li>结构体是值类型</li>
</ol>
<h2 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名称 <span class="keyword">struct</span> &#123;</span><br><span class="line">    名称 类型 <span class="comment">// 成员或属性</span></span><br><span class="line">    名称 类型 <span class="comment">// 成员或属性</span></span><br><span class="line">    名称 类型 <span class="comment">// 成员或属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体标记"><a href="#结构体标记" class="headerlink" title="结构体标记"></a>结构体标记</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名称 <span class="keyword">struct</span> &#123;</span><br><span class="line">    名称 类型 <span class="string">`key:"Value"`</span>    <span class="comment">// 无空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name    <span class="keyword">string</span> <span class="string">`tag:"name"`</span></span><br><span class="line">	Address <span class="keyword">string</span> <span class="string">`tag:"address"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h2><ol>
<li>像变量一样，结构体可以定义在函数内部或者外部，定义位置决定了访问范围</li>
<li>如果结构体定义在函数外部，则其首字母是否大写，影响到是否能跨包访问</li>
<li>如果结构体能跨包访问，其内部属性名称首字母是否大写，影响到是否能跨包访问</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 按顺序赋值</span></span><br><span class="line">	yjh := People&#123;<span class="string">"yangjinheng"</span>, <span class="number">30</span>&#125;</span><br><span class="line">	fmt.Println(yjh.Name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指定属性赋值</span></span><br><span class="line">	yzx := People&#123;Age: <span class="number">27</span>, Name: <span class="string">"yangzhongxiao"</span>&#125;</span><br><span class="line">	fmt.Println(yzx.Name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 单独赋值</span></span><br><span class="line">	<span class="keyword">var</span> yyj People</span><br><span class="line">	yyj.Name = <span class="string">"yangyanjun"</span></span><br><span class="line">	yyj.Age = <span class="number">56</span></span><br><span class="line">	fmt.Println(yyj.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">yangjinheng</span><br><span class="line">yangzhongxiao</span><br><span class="line">yangyanjun</span><br></pre></td></tr></table></figure>
<h2 id="等值判断"><a href="#等值判断" class="headerlink" title="等值判断"></a>等值判断</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	yjh1 := People&#123;<span class="string">"yangjinheng"</span>, <span class="number">30</span>&#125;</span><br><span class="line">	yjh2 := People&#123;<span class="string">"yangjinheng"</span>, <span class="number">30</span>&#125;</span><br><span class="line">	yzx1 := People&#123;<span class="string">"yangzhongxiao"</span>, <span class="number">27</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由于结构体为值类型，可以使用 == 来进行等值比较</span></span><br><span class="line">	fmt.Println(yjh1 == yjh2)</span><br><span class="line">	fmt.Println(yjh1 == yzx1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>由于结构体是值类型，在方法传递时希望传递结构体地址，可以使用结构体指针完成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// new 函数可以创建结构体指针</span></span><br><span class="line">	yjh1 := <span class="built_in">new</span>(People)</span><br><span class="line">	yjh1.Name = <span class="string">"yangjinheng"</span></span><br><span class="line">	yjh1.Age = <span class="number">30</span></span><br><span class="line">	fmt.Println(yjh1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用 &amp; 符号来创建结构体指针</span></span><br><span class="line">	yjh2 := &amp;People&#123;<span class="string">"yangjinheng"</span>, <span class="number">30</span>&#125;</span><br><span class="line">	fmt.Println(yjh2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 引用类型的等值比较比的是内存地址，所以此处为 false</span></span><br><span class="line">	fmt.Println(yjh1 == yjh2)</span><br><span class="line">	fmt.Println(*yjh1 == *yjh2)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&amp;&#123;yangjinheng <span class="number">30</span>&#125;</span><br><span class="line">&amp;&#123;yangjinheng <span class="number">30</span>&#125;</span><br><span class="line"><span class="literal">false</span>              <span class="comment">// 结构体指针为指针类型，比较内存地址，所以为 false</span></span><br><span class="line"><span class="literal">true</span>               <span class="comment">// 结构体为值类型，比较内容，所以为 true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>结构体指针是引用类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// new 函数可以创建结构体指针</span></span><br><span class="line">	yjh1 := <span class="built_in">new</span>(People)</span><br><span class="line">	yjh1.Name = <span class="string">"yangjinheng"</span></span><br><span class="line">	yjh1.Age = <span class="number">30</span></span><br><span class="line">	fmt.Println(yjh1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 结构体指针是引用类型</span></span><br><span class="line">	yjh3 := yjh1</span><br><span class="line">	yjh3.Name = <span class="string">"杨金恒"</span></span><br><span class="line">	fmt.Println(yjh1, yjh3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&amp;&#123;yangjinheng <span class="number">30</span>&#125;</span><br><span class="line">&amp;&#123;杨金恒 <span class="number">30</span>&#125; &amp;&#123;杨金恒 <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法的使用"><a href="#方法的使用" class="headerlink" title="方法的使用"></a>方法的使用</h2><ol>
<li>方法和函数语法比较像，区别是函数是属于包，通过包调用，而方法属于结构体，通过结构体变量调用</li>
<li>默认是函数，隶属于包，所以需要添加标识，告诉编译器这个方法属于那个结构体</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(变量名 结构体类型)</span> 方法名<span class="params">(参数列表)</span> 返回值列表</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Go 语言中已经有函数了，添加方法的支持主要是保证 Go 语言是面向对象的。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">官方：虽然面向对象没有统一的定义，但是对于我们来说对象仅仅是一个有着方法的值或变量，而方法就是一个属于特定类型的函数</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>方法的简单示例</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Age    <span class="keyword">int</span></span><br><span class="line">	Weight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span> <span class="title">play</span><span class="params">()</span></span> &#123;  <span class="comment">// 赋值给方法的 p 为结构体</span></span><br><span class="line">	fmt.Println(<span class="string">"我是"</span>, p.Name, <span class="string">"今年"</span>, p.Age, <span class="string">"岁，体重"</span>, p.Weight)</span><br><span class="line">	p.Weight -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">run</span><span class="params">()</span></span> &#123;  <span class="comment">// 赋值给方法的 p 为结构体指针</span></span><br><span class="line">	fmt.Println(<span class="string">"我是"</span>, p.Name, <span class="string">"今年"</span>, p.Age, <span class="string">"岁，体重"</span>, p.Weight)</span><br><span class="line">	p.Weight -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	yjh1 := People&#123;<span class="string">"yangjinheng"</span>, <span class="number">30</span>, <span class="number">65</span>&#125;</span><br><span class="line">	yjh1.play()</span><br><span class="line">	yjh1.play()</span><br><span class="line"></span><br><span class="line">	yjh1.run()</span><br><span class="line">	yjh1.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">我是 yangjinheng 今年 <span class="number">30</span> 岁，体重 <span class="number">65</span></span><br><span class="line">我是 yangjinheng 今年 <span class="number">30</span> 岁，体重 <span class="number">65</span>    <span class="comment">// 当方法接收的是结构体，则方法对结构体的修改不能改变结构体内容</span></span><br><span class="line">我是 yangjinheng 今年 <span class="number">30</span> 岁，体重 <span class="number">65</span></span><br><span class="line">我是 yangjinheng 今年 <span class="number">30</span> 岁，体重 <span class="number">64</span>    <span class="comment">// 当方法接收的是结构体指针，则方法对结构体的修改会改变结构体内容</span></span><br></pre></td></tr></table></figure>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><ol>
<li>在 Go 语言标准库中 refect 包提供了运行时反射，在程序运行过程中动态操作结构体</li>
<li>如果想通过一个字符串来对结构体的某个属性进行赋值查看时，就可以使用反射</li>
<li>反射还可以用作判断变量类型</li>
<li>整个 reflect 包中有两个重要的类型：reflect.Type 类型，reflect.Value 值</li>
<li>获取到 Type 和 Value 的函数：reflect.TypeOf(interface{}) 获取类型，reflect.ValueOf(interface{}) 获取值</li>
</ol>
<h2 id="判断变量类型"><a href="#判断变量类型" class="headerlink" title="判断变量类型"></a>判断变量类型</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">1.5</span></span><br><span class="line">	fmt.Println(reflect.TypeOf(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="获取结构体属性值"><a href="#获取结构体属性值" class="headerlink" title="获取结构体属性值"></a>获取结构体属性值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	peo := People&#123;<span class="number">1</span>, <span class="string">"杨金恒"</span>&#125;</span><br><span class="line"></span><br><span class="line">	v := reflect.ValueOf(peo)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取属性的个数</span></span><br><span class="line">	fmt.Println(v.NumField())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据 index 获取</span></span><br><span class="line">	fmt.Println(v.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据字符串反射</span></span><br><span class="line">	fmt.Println(v.FieldByName(<span class="string">"Name"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射修改属性的值，"><a href="#反射修改属性的值，" class="headerlink" title="反射修改属性的值，"></a>反射修改属性的值，</h2><p>需要传递结构体指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用结构体指针</span></span><br><span class="line">	peo := &amp;People&#123;<span class="number">1</span>, <span class="string">"杨金恒"</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果对象是指针类型，则需要添加 Elem</span></span><br><span class="line">	v := reflect.ValueOf(peo).Elem()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CanSet 表示反射的值是否可以修改，如果需要修改则要求属性名称首字母大写</span></span><br><span class="line">	fmt.Println(v.FieldByName(<span class="string">"Name"</span>).CanSet())</span><br><span class="line">	v.FieldByName(<span class="string">"Name"</span>).SetString(<span class="string">"yangjinheng"</span>)</span><br><span class="line">	fmt.Println(v.FieldByName(<span class="string">"Name"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射获取结构体的标记"><a href="#反射获取结构体的标记" class="headerlink" title="反射获取结构体的标记"></a>反射获取结构体的标记</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id   <span class="keyword">int</span>    <span class="string">`flag:"bianhao"`</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`flag:"xingming"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取标记</span></span><br><span class="line">	t := reflect.TypeOf(People&#123;&#125;)</span><br><span class="line">	fmt.Println(t.FieldByName(<span class="string">"Name"</span>))</span><br><span class="line">	name, _ := t.FieldByName(<span class="string">"Name"</span>)</span><br><span class="line">	fmt.Println(name.Tag.Get(<span class="string">"flag"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>Go 语言有着自己对面向对象的理解，它也有自己的封装、继承、多态。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装主要体现在两个方面：封装数据、封装业务</p>
<p>Go 语言中通过首字母大小写控制访问权限，属性首字母小写，方法首字母大写对外提供，是封装数据的最常见方式</p>
<ol>
<li>可以通过方法封装业务，提出方法封装业务</li>
<li>控制结构体属性访问，对外提供访问方法也是封装</li>
</ol>
<p>在面向对象中封装的好处：</p>
<ol>
<li>安全性，结构体属性访问受到限制，必须按照特定的访问渠道</li>
<li>可复用性，封装的方法实现可复用性</li>
<li>可读写，多段代码增加代码可读性</li>
</ol>
<h3 id="封装代码示例"><a href="#封装代码示例" class="headerlink" title="封装代码示例"></a>封装代码示例</h3><ul>
<li>封装的代码示例：src/people/people.go</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> people</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span>                               <span class="comment">// 虽然结构体首字母大写可以被访问，但是结构体内部的属性没有大写，所以不能跨包访问</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">SetName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;       <span class="comment">// 封装体现在了这个方法上，虽然属性不能对外访问，但是提供了操作属性的方法</span></span><br><span class="line">	p.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>风格装的代码示例：main.go</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"people"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	yjh := <span class="built_in">new</span>(people.People)</span><br><span class="line">	yjh.SetName(<span class="string">"yangjinheng"</span>)              <span class="comment">// 调用封装好的接口</span></span><br><span class="line">	name := yjh.GetName()</span><br><span class="line">	fmt.Println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承就是把同一类的事物提出共同点为父类，让子类可以复用父类的可访问性内容</p>
<p>继承有多种实现方式</p>
<ol>
<li>通过关键字继承，强耦合实现方式</li>
<li>组合方式继承，松耦合继承方式</li>
</ol>
<p>使用过 Java 和 C# 的应该知道尽量少用继承，而使用组合代替继承，可以使用高内聚，低耦合，Java 之父在之前一次的采访中说过，如果给他一次机会重新做 Java 他最希望修改的就是继承</p>
<p>GO 语言中的继承是通过组合方式实现，Javascript 也是通过组合方式（原型和原型链）。</p>
<h3 id="匿名属性"><a href="#匿名属性" class="headerlink" title="匿名属性"></a>匿名属性</h3><p>在 Go 语言结构体中支持匿名属性（结构体中属性的名字），直接使用数据类型作为属性名，每个匿名属性的类型都必须不同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> people <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := people&#123;<span class="string">"yangjinheng"</span>, <span class="number">30</span>&#125;</span><br><span class="line">	fmt.Println(p.<span class="keyword">string</span>, p.<span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="传统面向对象"><a href="#传统面向对象" class="headerlink" title="传统面向对象"></a>传统面向对象</h3><p>传统面向对象中类与类之间的关系：</p>
<ol>
<li>继承：is-a 强耦合性，一般认为类与类之间具有强耦合关系</li>
<li>实现：like-a 接口和实现类之间的关系</li>
<li>依赖：use-a 具有偶然性、临时性、非常弱的，但是 B 类的变化也会影响到 A，一般作为参数</li>
<li>关联：has-a 一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的</li>
<li>聚合：has-a 整体与部分、拥有的关系</li>
<li>组合：contains-a（包含），他体现的是一种 contains-a 的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的声明周期结束也就意味着部分的声明周期结束</li>
<li>组合 &gt; 聚合 &gt; 关联 &gt; 依赖</li>
</ol>
<h3 id="Go语言中组合关系"><a href="#Go语言中组合关系" class="headerlink" title="Go语言中组合关系"></a>Go语言中组合关系</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">	peo       People</span><br><span class="line">	classroom <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tea := Teacher&#123;People&#123;<span class="string">"yangjinheng"</span>, <span class="number">30</span>&#125;, <span class="string">"linux"</span>&#125;</span><br><span class="line">	fmt.Println(tea.peo.name, tea.peo.age, tea.classroom)  <span class="comment">// 还需要使用属性来访问组合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">yangjinheng <span class="number">30</span> linux</span><br></pre></td></tr></table></figure>
<ul>
<li>利用匿名属性来访问对象</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">	People                                   <span class="comment">// 利用匿名属性来组合</span></span><br><span class="line">	classroom <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//type Teacher struct &#123;                      // 编译器中会认为是这样</span></span><br><span class="line"><span class="comment">//    name string</span></span><br><span class="line"><span class="comment">//    age  int</span></span><br><span class="line"><span class="comment">//    classroom string</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tea := Teacher&#123;People&#123;<span class="string">"yangjinheng"</span>, <span class="number">30</span>&#125;, <span class="string">"linux"</span>&#125;</span><br><span class="line">	fmt.Println(tea.name, tea.age, tea.classroom)       <span class="comment">// 直接访问组合后的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">yangjinheng <span class="number">30</span> linux</span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ol>
<li>接口是一组行为规范的定义</li>
<li>接口中只能有方法声明，方法只有名称、参数、返回值，不能有方法体</li>
<li>每个接口中可以有多个方法声明，结构体把接口中 “所有” 方法都重写后，结构体就属于接口类型</li>
<li>Go 语言中接口和结构体之间的关系是传统面向对象中的 is-like-a 的关系</li>
<li>定义接口类型关键字是 interface</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 接口名 <span class="keyword">interface</span> &#123;</span><br><span class="line">    方法名(参数列表) 返回值列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>接口可以继承接口，且 Go 语言推荐把接口中方法拆分成多个接口</li>
</ol>
<h3 id="接口代码示例"><a href="#接口代码示例" class="headerlink" title="接口代码示例"></a>接口代码示例</h3><p>接口中声明完方法，结构体重写接口中方法后，编译器就认为结构体实现了接口</p>
<p>重写方法要求必须和接口中方法名称、方法参数（参数名称可以不同）、返回值列表完全相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Live <span class="keyword">interface</span> &#123;             <span class="comment">// 接口是一组行为规范</span></span><br><span class="line">	run(run <span class="keyword">int</span>)                  <span class="comment">// 接口只声明了方法，且不能有方法体</span></span><br><span class="line">	eat()                         <span class="comment">// 可以有多个方法声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">run</span><span class="params">(run <span class="keyword">int</span>)</span></span> &#123;                     <span class="comment">// 重写 run 方法</span></span><br><span class="line">	fmt.Println(p.name, <span class="string">"正在跑步，跑了"</span>, run, <span class="string">"米"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;                            <span class="comment">// 重写 eat 方法</span></span><br><span class="line">	fmt.Println(p.name, <span class="string">"正在吃饭"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	peo := People&#123;<span class="string">"张三"</span>, <span class="number">30</span>&#125;</span><br><span class="line">	peo.run(<span class="number">100</span>)</span><br><span class="line">	peo.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果现在有另外一个结构体需要只实现 eat 方法即可，那么可以进行一下的拆分组合</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -------------------------------------------------- 公共接口 --------------------------------------------------</span></span><br><span class="line"><span class="keyword">type</span> Eat <span class="keyword">interface</span> &#123;                           <span class="comment">// 将 Eat 接口拆分出来</span></span><br><span class="line">	eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------- 组合 eat 和 run 方法 --------------------------------------------------</span></span><br><span class="line"><span class="keyword">type</span> Live <span class="keyword">interface</span> &#123;                          <span class="comment">// 在 Live 中组合 Eat 方法</span></span><br><span class="line">	run(run <span class="keyword">int</span>)</span><br><span class="line">	Eat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">run</span><span class="params">(run <span class="keyword">int</span>)</span></span> &#123;                      <span class="comment">// 实现 run 接口</span></span><br><span class="line">	fmt.Println(p.name, <span class="string">"正在跑步，跑了"</span>, run, <span class="string">"米"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;                             <span class="comment">// 实现 eat 接口</span></span><br><span class="line">	fmt.Println(p.name, <span class="string">"正在吃饭"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------- 狗 --------------------------------------------------</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="keyword">string</span></span><br><span class="line">	color <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Dog)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;                             <span class="comment">// 仅仅实现 eat 接口</span></span><br><span class="line">	fmt.Println(p.name, <span class="string">"正在吃饭"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 人实现了 eat 和 run</span></span><br><span class="line">	yjh := People&#123;<span class="string">"杨金恒"</span>, <span class="number">30</span>&#125;</span><br><span class="line">	yjh.run(<span class="number">100</span>)</span><br><span class="line">	yjh.eat()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 狗只实现了 eat</span></span><br><span class="line">	erha := Dog&#123;<span class="string">"二哈"</span>, <span class="string">"白色"</span>&#125;</span><br><span class="line">	erha.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口类型结构体"><a href="#接口类型结构体" class="headerlink" title="接口类型结构体"></a>接口类型结构体</h3><p>结构体实现了接口的全部方法，就认为结构体属于接口类型，这时可以把结构体变量赋值给接口变量</p>
<ul>
<li>重写接口时接收者为 Type 和 *Type 的区别</li>
</ul>
<ol>
<li><em>Type 可以调用 </em>Type 和 Type 作为接口者的方法，所以只要接口中多个方法至少出现一个使用 *Type 作为接收者进行重写的方法，就必须把结构体指针赋值给接口变量，否则编译报错</li>
<li>Type 只能调用 Type 作为接收者的方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Live <span class="keyword">interface</span> &#123;</span><br><span class="line">	run()</span><br><span class="line">	eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(p.name, <span class="string">"正在跑步"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p People)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(p.name, <span class="string">"正在吃饭"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> people Live = &amp;People&#123;<span class="string">"杨金恒"</span>&#125; <span class="comment">// People 实现了接口的全部方法，所以可以把结构体变量赋值给接口变量</span></span><br><span class="line">	<span class="comment">// people := &amp;People&#123;"杨金恒"&#125;</span></span><br><span class="line">	people.run()                     <span class="comment">// 结构体方法中只要出现一个是以一个 *Type 作为接收者重写的方法，就必须将结构体指针变量赋值给接口变量</span></span><br><span class="line">	people.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么使用接口"><a href="#为什么使用接口" class="headerlink" title="为什么使用接口"></a>为什么使用接口</h3><p>什么是接口，接口的作用是用来通讯的吧，通讯就涉及到客户端和服务端。</p>
<p>现在假设你写了一个开源的包，比如叫：gRPC。我们这里把 gRPC 内部的服务称为服务端，而把调用 gRPC 的应用称作客户端。</p>
<p>现在在双方通讯过程中有这么一个需求，当在客户端调用服务端方法的时候，服务端同时也需要执行客户端的特定方法。</p>
<p>这个需求怎么实现？gRPC 包必须定义一个接口，这个接口只有一些函数定义，没有具体实现。而实现这个接口需要由客户端来做。</p>
<p>客户端只有全部实现了服务端的接口函数，服务端才能执行客户端的函数。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态：同一个事情由于条件不同产生的结果不同</p>
<p>由于 Go 语言中结构体不能相互转换，所以没有结构体（父子结构体）的多态，只有基于接口的多态，这也符合 Go 语言对面向对象的诠释</p>
<p>多态在代码层面最常见的一种方式是接口当作方法参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Live <span class="keyword">interface</span> &#123;</span><br><span class="line">	eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *People)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(p.name, <span class="string">"在吃饭"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Dog)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(p.name, <span class="string">"在吃饭"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">alleat</span><span class="params">(live Live)</span></span> &#123;</span><br><span class="line">	live.eat()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	peo := &amp;People&#123;<span class="string">"杨金恒"</span>&#125;</span><br><span class="line">	dog := &amp;Dog&#123;<span class="string">"哈士奇"</span>&#125;</span><br><span class="line">	alleat(peo)</span><br><span class="line">	alleat(dog)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于接口在给定不同的参数时，程序的执行结果不同，这就是代码层面多态的表现</p>
<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><ol>
<li>只要实现了接口的全部方法，就认为这个类型属于接口类型，如果编写一个接口，这个接口中没有任何方法，这时就认为所有类型都实现了这个接口，所以 Go 语言中 interface{} 代表任意类型。</li>
<li>如果 interface{} 作为方法参数就可以接收任意类型，但是在程序中有时需要知道这个参数到底是什么类型，这时候就需要使用断言</li>
<li>断言使用时使用 interface{} 变量点括号，括号中判断是否属于的类型</li>
<li>断言有两个作用，一个是判断类型，一个是类型转换</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">i.(Type)</span><br></pre></td></tr></table></figure>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>断言可以有一个返回值，如果判断结果是指定类型则返回变量值，如果不是指定类型则报错</p>
<ul>
<li>当断言接收的参数为一个时，如果断言失败，则会抛出异常</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	result := i.(<span class="keyword">int</span>)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	demo(<span class="number">6543</span>)</span><br><span class="line">	demo(<span class="string">"测试"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">6543</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>: <span class="keyword">interface</span> conversion: <span class="keyword">interface</span> &#123;&#125; is <span class="keyword">string</span>, not <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<ul>
<li>接收两个参数，如果断言失败，则会将结果返回到第二个参数中</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	result, ok := i.(<span class="keyword">int</span>)</span><br><span class="line">	fmt.Println(result, ok)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	demo(<span class="number">6543</span>)</span><br><span class="line">	demo(<span class="string">"测试"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h1><p>在程序执行过程中出现的不正常情况称之为错误，Go 语言中使用 builtin 包下的 error 接口作为错误类型，官方源码如下，只包含了一个方法，返回值是 string 表示错误信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Go 语言中错误都是作为 方法/函数 的返回值，因为 Go 语言认为使用其他语言类似 try/catch 这种方式会影响到程序结构</p>
<p>在 Go 语言标准库 errors 包中提供了 error 接口的实现结构体 errorString 并重写了 error 接口的 Error() 方法，额外提供了快速创建错误的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> errors</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">    s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果错误信息又很多变量（小块）组成，可以借助 fmt.Errorf(“verb”, …) 完成错误信息格式化，因为底层还是 errors.New()，底层代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> error.New(Sprintf(format, a...))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><ul>
<li>原则上来讲每个错误都是需要处理的，处理的方式就是通过条件分支去判断</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(i, k <span class="keyword">int</span>)</span> <span class="params">(r <span class="keyword">int</span>, e error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">//e = errors.New("除数不能为零")         // 内置接口自定义错误</span></span><br><span class="line">        e = fmt.Errorf(<span class="string">"%d 不能除以 0"</span>, i)      <span class="comment">// fmt 自定义错误</span></span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	r = i / k</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// result, err := demo(100, 2)</span></span><br><span class="line">	result, err := demo(<span class="number">100</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(result, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"程序出错"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h1><p>Go 语言中 defer 可以完成延迟功能，当前函数执行完成后执行 defer 功能</p>
<p>defer 最常用的就是关闭连接（关闭数据库连接），可以打开连接后代码紧跟着 defer 关闭连接，后面再执行其他功能</p>
<p>在很多语言中要求必须按照顺序执行，也就是必须把关闭代码写在最后，但是经常会忘记关闭，导致内存溢出，而 Go 语言中 defer 很好的解决了这个问题，无论 defer 写到哪里都是最后执行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"打开连接"</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"关闭连接"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(<span class="string">"进行操作"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">打开连接</span><br><span class="line">进行操作</span><br><span class="line">关闭连接</span><br></pre></td></tr></table></figure>
<h2 id="多个-defer"><a href="#多个-defer" class="headerlink" title="多个 defer"></a>多个 defer</h2><p>多个 defer 代码块，则会采用栈结构执行，就是最先声明的最后执行</p>
<p>在很多代码结构中很可能出现多个对象，而程序希望这些对象倒序关闭，多个 defer 很好的解决了这个问题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"打开连接A"</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"关闭连接A"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">"打开连接B"</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"关闭连接B"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">"进行操作"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">打开连接A</span><br><span class="line">打开连接B</span><br><span class="line">进行操作</span><br><span class="line">关闭连接B</span><br><span class="line">关闭连接A</span><br></pre></td></tr></table></figure>
<h2 id="defer-结合-return-结合"><a href="#defer-结合-return-结合" class="headerlink" title="defer 结合 return 结合"></a>defer 结合 return 结合</h2><p>defer 与 return 同时存在时，要把 return 理解成两条执行结合（不是原子指令），一个指令是给返回值赋值，另一个指令返回跳出函数</p>
<p>defer 和 return 结合时，整体执行顺序：1. 给返回值赋值 2. 执行 defer 3. 跳出函数</p>
<ul>
<li>没有定义返回值接收变量，执行 defer 时返回值已经赋值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;     <span class="comment">// 2. 执行 defer 改变 i 的值</span></span><br><span class="line">        i = i+<span class="number">2</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> i           <span class="comment">// 1. 为返回值赋值 3. 跳出函数返回返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(f())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义了返回值接收变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;     <span class="comment">// 2. 执行 defer 为返回值变量 z 赋值</span></span><br><span class="line">		z = i + <span class="number">2</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span>             <span class="comment">// 1. 无法为返回值赋值 3. 跳出函数返回返回值变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(f())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 首先执行 <span class="keyword">return</span> 给返回值赋值，但 <span class="keyword">return</span> 后没有内容，无法给返回值赋值</span><br><span class="line"><span class="number">2.</span> 执行 <span class="keyword">defer</span> 此时为返回值变量赋值</span><br><span class="line"><span class="number">3.</span> 跳出函数</span><br></pre></td></tr></table></figure>
<ul>
<li>return 为返回值赋值，同时 defer 也为范围值赋值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="params">(z <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;     <span class="comment">// 2. 执行 defer 为返回值变量 z 再次赋值</span></span><br><span class="line">		z = i + <span class="number">2</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> i           <span class="comment">// 1. 将 i 的值赋值给返回值变量 z 3. 跳出函数返回返回值变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(f())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>panic 函数相当于抛出异常，recover 函数相当于捕获并抑制异常。</p>
<h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p>panic 是 builtin 中的函数，有点类似于其他编程语言中的 throw 抛出异常，当执行到 panic 后终止剩余代码执行并打印错误栈信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"1"</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"panic 执行了"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"2"</span>)           <span class="comment">// 这个语句不会被执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="built_in">panic</span>: <span class="built_in">panic</span> 执行了</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">	c:/Users/LENOVO/OneDrive/文档/笔记~Go语言/test/main.<span class="keyword">go</span>:<span class="number">7</span> +<span class="number">0x9c</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意 panic 不是立即停止程序（os.Exit(0)），defer 还是可以执行的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"defer 执行了"</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">"1"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"panic 执行了"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">defer</span> 执行了</span><br><span class="line"><span class="built_in">panic</span>: <span class="built_in">panic</span> 执行了</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [running]:</span><br><span class="line">main.main()</span><br><span class="line">	c:/Users/LENOVO/OneDrive/文档/笔记~Go语言/test/main.<span class="keyword">go</span>:<span class="number">10</span> +<span class="number">0xd3</span></span><br></pre></td></tr></table></figure>
<h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p>recover() 和 panic(v) 都是 builtin 中的函数，可以接收 panic 的信息，恢复程序的 panic() 状态让程序正常运行。</p>
<p>recover() 一般用在 defer 内部，如果没有 panic 信息返回 nil，如果有 panic recover    会把 panic 状态取消。</p>
<ol>
<li>可以接收 panic 的信息，并抑制 panic 继续向外传递，但剩余代码不再执行</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		error := <span class="built_in">recover</span>()   <span class="comment">// 可以接收 panic 的信息，并抑制 panic 继续向外传递</span></span><br><span class="line">		<span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"获取到 panic 信息为"</span>, error)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">"1"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"出现了 panic"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">获取到 <span class="built_in">panic</span> 信息为 出现了 <span class="built_in">panic</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>panic 会在函数调用链中一直向上传递，如果没有遇到 recover() 则会终止程序。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"demo1上半部分"</span>)</span><br><span class="line">	demo2()</span><br><span class="line">	fmt.Println(<span class="string">"demo1下半部分"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"demo2上半部分"</span>)</span><br><span class="line">	demo3()</span><br><span class="line">	fmt.Println(<span class="string">"demo2下半部分"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"demo3上半部分"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"在 demo3 出现了 panic"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"demo3下半部分"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"程序开始"</span>)</span><br><span class="line">	demo1()</span><br><span class="line">	fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">程序开始</span><br><span class="line">demo1上半部分</span><br><span class="line">demo2上半部分</span><br><span class="line">demo3上半部分</span><br><span class="line"><span class="built_in">panic</span>: 在 demo3 出现了 <span class="built_in">panic</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>被 recover() 恢复后的函数不会继续执行，但是 panic 被抑制，所以调用链正常结束</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"demo1上半部分"</span>)</span><br><span class="line">	demo2()</span><br><span class="line">	fmt.Println(<span class="string">"demo1下半部分"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">recover</span>()</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">"demo2上半部分"</span>)</span><br><span class="line">	demo3()</span><br><span class="line">	fmt.Println(<span class="string">"demo2下半部分"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"demo3上半部分"</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">"在 demo3 出现了 panic"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"demo3下半部分"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"程序开始"</span>)</span><br><span class="line">	demo1()</span><br><span class="line">	fmt.Println(<span class="string">"程序结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">程序开始</span><br><span class="line">demo1上半部分</span><br><span class="line">demo2上半部分</span><br><span class="line">demo3上半部分</span><br><span class="line">demo1下半部分</span><br><span class="line">程序结束</span><br></pre></td></tr></table></figure>
<h1 id="routine"><a href="#routine" class="headerlink" title="routine"></a>routine</h1><p>Go 语言中最迷人的一点就是从语言层面支持并发，goroutine(协程)，类似于其他语言的线程</p>
<h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><ol>
<li>并行：指的不同的代码片段同时在不同的物理处理器上支持</li>
<li>并发：指的同时管理多个事情，物理服务器在多个事情之间切换</li>
<li>一般看来并发的性能要好于并行，因为计算机的物理资源是固定的，较少的，而程序执行的内容是很多的，所以并发是以较少的资源去做更多的事情</li>
</ol>
<h2 id="并发模型"><a href="#并发模型" class="headerlink" title="并发模型"></a>并发模型</h2><ol>
<li>多线程，每个线程只处理一个请求，只有请求结束后，线程才会接收下一个请求，这种请求模式在高并发下性能开销极大。</li>
<li>基于回调的异步IO，在程序运行过程中可能产生大量回调导致维护成本加大，程序执行流程也不便于思维<ol>
<li>协程，不需要抢占式调用，可以有效的提升线程任务的并发性，弥补了多线程模式的缺点，Go 语言层面就支持，而其他语言支持很少</li>
</ol>
</li>
</ol>
<h2 id="goroutine-语法"><a href="#goroutine-语法" class="headerlink" title="goroutine 语法"></a>goroutine 语法</h2><ol>
<li>表达式可以是一条语句</li>
<li>表达式也可以是函数，函数返回值即使有，也无效，当函数执行完成此 goroutine 自动结束</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 表达式</span><br></pre></td></tr></table></figure>
<h2 id="goroutine-示例"><a href="#goroutine-示例" class="headerlink" title="goroutine 示例"></a>goroutine 示例</h2><ul>
<li>下面例子，demo 函数执行约需要 1 秒，调用了 5 次，由于必须等待 demo 返回，所以串行执行约需 5 秒</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		fmt.Println(count, i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t0 := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		demo(i)</span><br><span class="line">	&#125;</span><br><span class="line">	t1 := time.Since(t0)</span><br><span class="line">	fmt.Println(<span class="string">"用时"</span>, t1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 goroutine 以后，每个 demo 函数有单独协程，不需要等待返回才执行下一个，所以并发会很快</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		fmt.Println(count, i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t0 := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> demo(i)        <span class="comment">// go 关键字就是 go 语言提供的 goroutine 原生支持</span></span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">2e9</span>)       <span class="comment">// 在这里等待所有 goroutine 的完成，否则主线程直接退出了</span></span><br><span class="line">	t1 := time.Since(t0)</span><br><span class="line">	fmt.Println(<span class="string">"用时"</span>, t1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="waitGroup"><a href="#waitGroup" class="headerlink" title="waitGroup"></a>waitGroup</h2><p>Go 语言中 sync 包提供了基本同步单元，如互斥锁等，除了 once 和 WaitGroup 类型，大部分都只适用于低水平程序线程，高水平程序线程使用 channel 通信会更好一些。</p>
<p>WaitGroup 直译为等待组，其实就是计数器，只要计数器中有内容将一直阻塞。</p>
<p>在 Go 语言中， WaitGroup 存在于 sync 包中，在 Sync 包中类型都不应该被拷贝的，源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    state [<span class="number">12</span>]<span class="keyword">byte</span></span><br><span class="line">    same <span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 waitgroup 库中 waitgroup 只有三个方法</p>
<ol>
<li>Add(delta int) 表示向内部计数器添加增量（dalta），其中参数 delta 可以是负数</li>
<li>Done() 表示减少 WaitGroup 计数器的值，应当在程序最后执行，相当于 Add(-1)</li>
<li>Wait() 表示阻塞直到 WaitGroup 计数器为 0，必须在主线程中</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li>waitGroup 使用示例</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t0 := time.Now()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)                   <span class="comment">// 每次创建一个 goroutine 时候增加一个等待</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">            fmt.Println(count)</span><br><span class="line">            wg.Done()               <span class="comment">// 当 goroutine 执行完成后减少一个等待</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()                       <span class="comment">// 当等待组没有需要等待的计数，则等待完成</span></span><br><span class="line">	t1 := time.Since(t0)</span><br><span class="line">	fmt.Println(<span class="string">"用时"</span>, t1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>多个协程操作一个变量时候，会出现冲突的问题，这时候就需要锁，可以使用 sync.Mutex 对内容加锁</p>
<p>在 Go 语言中 go run -race 可以查看竞争，如果出现竞争，则可能表示程序写的不完备</p>
<h2 id="互斥锁的使用场景"><a href="#互斥锁的使用场景" class="headerlink" title="互斥锁的使用场景"></a>互斥锁的使用场景</h2><ol>
<li>多个 goroutine 访问同一个函数(代码段)</li>
<li>这个函数操作一个全局变量</li>
<li>为了保证共享变量安全性，值的合法性</li>
</ol>
<h2 id="没有互斥锁代码"><a href="#没有互斥锁代码" class="headerlink" title="没有互斥锁代码"></a>没有互斥锁代码</h2><p>num 初始值为 100，demo 函数会循环 10 次每次减去 1，main 函数会启动 100 个 goroutine 调用 demo 函数，100 - 100 * 10 = 0，正确结果应该是 0。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	num = <span class="number">1000</span></span><br><span class="line">	wg  sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		num--</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> demo()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">API server listening at: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">13222</span></span><br><span class="line"><span class="number">5</span>                                                   <span class="comment">// 由于竞争，最终的结果是错误的</span></span><br><span class="line">Process exiting with code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 go run -race 查看竞争</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: DATA RACE                                                <span class="comment">// 警告数据竞争</span></span><br><span class="line">Read at <span class="number">0x0000005e1338</span> by goroutine <span class="number">8</span>:</span><br><span class="line">  main.demo()</span><br><span class="line">      C:/Users/LENOVO/Desktop/golang/lock/main.<span class="keyword">go</span>:<span class="number">17</span> +<span class="number">0x4e</span></span><br><span class="line"></span><br><span class="line">Previous write at <span class="number">0x0000005e1338</span> by goroutine <span class="number">7</span>:</span><br><span class="line">  main.demo()</span><br><span class="line">      C:/Users/LENOVO/Desktop/golang/lock/main.<span class="keyword">go</span>:<span class="number">17</span> +<span class="number">0x6a</span></span><br><span class="line"></span><br><span class="line">Goroutine <span class="number">8</span> (running) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      C:/Users/LENOVO/Desktop/golang/lock/main.<span class="keyword">go</span>:<span class="number">26</span> +<span class="number">0x6f</span></span><br><span class="line"></span><br><span class="line">Goroutine <span class="number">7</span> (finished) created at:</span><br><span class="line">  main.main()</span><br><span class="line">      C:/Users/LENOVO/Desktop/golang/lock/main.<span class="keyword">go</span>:<span class="number">26</span> +<span class="number">0x6f</span></span><br><span class="line">==================</span><br><span class="line"><span class="number">0</span></span><br><span class="line">Found <span class="number">1</span> data race(s)                                              <span class="comment">// 存在一个数据竞争</span></span><br><span class="line">exit status <span class="number">66</span></span><br></pre></td></tr></table></figure>
<h2 id="使用互斥锁代码"><a href="#使用互斥锁代码" class="headerlink" title="使用互斥锁代码"></a>使用互斥锁代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	num = <span class="number">1000</span></span><br><span class="line">	wg  sync.WaitGroup</span><br><span class="line">	m   sync.Mutex                                                 <span class="comment">// 声明互斥锁</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m.Lock()                                                       <span class="comment">// 获取锁，如果成功才执行</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		num--</span><br><span class="line">	&#125;</span><br><span class="line">	m.Unlock()                                                     <span class="comment">// 释放锁</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> demo()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>                                                                  <span class="comment">// 结果正确</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 go run -race 查看竞争</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>                                                                  <span class="comment">// 没有数据竞争</span></span><br></pre></td></tr></table></figure>
<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	w           Mutex</span><br><span class="line">	writerSem   <span class="keyword">uint32</span></span><br><span class="line">	readerSem   <span class="keyword">uint32</span></span><br><span class="line">	readerCount <span class="keyword">int32</span></span><br><span class="line">	readerWait  <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Go 语言标准库中 PAI 如下</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Lock</span><span class="params">()</span>    // 禁止其他协程读写</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLock</span><span class="params">()</span>   // 禁止其他协程写入，只能读取</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RUnlock</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span> <span class="title">RLocker</span><span class="params">()</span> <span class="title">Locker</span></span></span><br></pre></td></tr></table></figure>
<p>Go 语言中的 map 不是线程安全的，多个 goroutine 同时操作会出现错误。</p>
<p>RWmutex 可以添加<strong>多个读锁或者一个写锁</strong>，<strong>读写锁不能同时存在</strong>。</p>
<ol>
<li>map 在并发下读写就需要结合读写锁完成</li>
<li>互斥锁表示只有获得锁的 goroutine 才能继续执行，而读写锁表示在锁范围内的读写操作</li>
</ol>
<h2 id="没有读写锁代码"><a href="#没有读写锁代码" class="headerlink" title="没有读写锁代码"></a>没有读写锁代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	data  = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	rw_wg sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	data[<span class="string">"key"</span>+strconv.Itoa(i)] = <span class="string">"value"</span> + strconv.Itoa(i)</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	rw_wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rw_wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> demo1(i)</span><br><span class="line">	&#125;</span><br><span class="line">	rw_wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fatal error: concurrent <span class="keyword">map</span> writes              <span class="comment">// 直接抛出错误不能执行，因为 map 不是线程安全的</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 go run -race 查看竞争</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[key0:value0]                                <span class="comment">// 存在数据竞争，并且无法执行程序</span></span><br><span class="line">==================</span><br><span class="line">WARNING: DATA RACE</span><br><span class="line">Write at <span class="number">0x00c00006c330</span> by goroutine <span class="number">8</span>:</span><br><span class="line">  runtime.mapassign_faststr()</span><br><span class="line">      D:/Program Files/Go/src/runtime/map_faststr.<span class="keyword">go</span>:<span class="number">202</span> +<span class="number">0x0</span>    </span><br><span class="line">  main.demo1()</span><br><span class="line">      C:/Users/LENOVO/Desktop/golang/lock/main.<span class="keyword">go</span>:<span class="number">44</span> +<span class="number">0x158</span></span><br><span class="line"></span><br><span class="line">Previous write at <span class="number">0x00c00006c330</span> by goroutine <span class="number">7</span>:</span><br><span class="line">  runtime.mapassign_faststr()</span><br><span class="line">      D:/Program Files/Go/src/runtime/map_faststr.<span class="keyword">go</span>:<span class="number">202</span> +<span class="number">0x0</span>    </span><br><span class="line">  main.demo1()</span><br><span class="line">      C:/Users/LENOVO/Desktop/golang/lock/main.<span class="keyword">go</span>:<span class="number">44</span> +<span class="number">0x158</span></span><br><span class="line"></span><br><span class="line">Goroutine <span class="number">8</span> (running) created at:</span><br><span class="line">  main.rwmutex()</span><br><span class="line">      C:/Users/LENOVO/Desktop/golang/lock/main.<span class="keyword">go</span>:<span class="number">53</span> +<span class="number">0x74</span></span><br><span class="line">  main.main()</span><br><span class="line">      C:/Users/LENOVO/Desktop/golang/lock/main.<span class="keyword">go</span>:<span class="number">61</span> +<span class="number">0x36</span></span><br><span class="line"></span><br><span class="line">Goroutine <span class="number">7</span> (running) created at:</span><br><span class="line">  main.rwmutex()</span><br><span class="line">      C:/Users/LENOVO/Desktop/golang/lock/main.<span class="keyword">go</span>:<span class="number">53</span> +<span class="number">0x74</span></span><br><span class="line">  main.main()</span><br><span class="line">      C:/Users/LENOVO/Desktop/golang/lock/main.<span class="keyword">go</span>:<span class="number">61</span> +<span class="number">0x36</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="使用读写锁代码"><a href="#使用读写锁代码" class="headerlink" title="使用读写锁代码"></a>使用读写锁代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	data  = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">	rw_wg sync.WaitGroup</span><br><span class="line">	rw_m  sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">demo1</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	rw_m.Lock()</span><br><span class="line">	data[<span class="string">"key"</span>+strconv.Itoa(i)] = <span class="string">"value"</span> + strconv.Itoa(i)</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">	rw_m.Unlock()</span><br><span class="line">	rw_wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rw_wg.Add(<span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> demo1(i)</span><br><span class="line">	&#125;</span><br><span class="line">	rw_wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">map</span>[key3:value3]</span><br><span class="line"><span class="keyword">map</span>[key3:value3 key9:value9]</span><br><span class="line"><span class="keyword">map</span>[key3:value3 key4:value4 key9:value9]</span><br><span class="line"><span class="keyword">map</span>[key3:value3 key4:value4 key5:value5 key9:value9]</span><br><span class="line"><span class="keyword">map</span>[key3:value3 key4:value4 key5:value5 key6:value6 key9:value9]</span><br><span class="line"><span class="keyword">map</span>[key3:value3 key4:value4 key5:value5 key6:value6 key7:value7 key9:value9]</span><br><span class="line"><span class="keyword">map</span>[key3:value3 key4:value4 key5:value5 key6:value6 key7:value7 key8:value8 key9:value9]</span><br><span class="line"><span class="keyword">map</span>[key1:value1 key3:value3 key4:value4 key5:value5 key6:value6 key7:value7 key8:value8 key9:value9]</span><br><span class="line"><span class="keyword">map</span>[key0:value0 key1:value1 key3:value3 key4:value4 key5:value5 key6:value6 key7:value7 key8:value8 key9:value9]</span><br><span class="line"><span class="keyword">map</span>[key0:value0 key1:value1 key2:value2 key3:value3 key4:value4 key5:value5 key6:value6 key7:value7 key8:value8 key9:value9]</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 go run -race 查看竞争</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">无竞争</span><br></pre></td></tr></table></figure>
<h2 id="读写锁和互斥锁"><a href="#读写锁和互斥锁" class="headerlink" title="读写锁和互斥锁"></a>读写锁和互斥锁</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 互斥锁，只有拿到了锁的 goroutine 才能继续向下执行</span><br><span class="line">2. 读写锁，只有拿到了锁的 goroutine 才能进行读写操作</span><br></pre></td></tr></table></figure>
<h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><p>channel 其实就是消息通信机制实现方案，在 Go 语言中没有使用共享内存完成线程通信，而是使用 channel 实现语言级别的 goroutine 之间通信</p>
<p>channel 在 Go 语言中主要的两个作用：1. 同步、2. 通信</p>
<p>Go 语言中的 Channel 的关键字是 chan，每个 channel 只能传递一个类型的数据，这个类型需要在声明中指定。</p>
<h2 id="声明语法"><a href="#声明语法" class="headerlink" title="声明语法"></a>声明语法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 名称 <span class="keyword">chan</span> 类型</span><br><span class="line"><span class="keyword">var</span> 名称 <span class="keyword">chan</span> &lt;- 类型        <span class="comment">// 只写</span></span><br><span class="line"><span class="keyword">var</span> 名称 &lt;- <span class="keyword">chan</span> 类型        <span class="comment">// 只读</span></span><br><span class="line">名称 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)      <span class="comment">// 无缓存 channel</span></span><br><span class="line">名称 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>)   <span class="comment">// 无缓存 channel</span></span><br><span class="line">名称 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>) <span class="comment">// 有缓存 channel</span></span><br></pre></td></tr></table></figure>
<p>操作 channel 的语法，假设 channel 名字为 ch：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- 值     <span class="comment">// 向 ch 中添加一个值</span></span><br><span class="line">&lt;- ch        <span class="comment">// 从 ch 中取出一个值</span></span><br><span class="line">a :=&lt;-ch     <span class="comment">// 从 ch 中取出一个值并赋值给 a</span></span><br><span class="line">a,b := &lt;-ch  <span class="comment">// 从 ch 中取出一个值赋值给 a ，如果 ch 已经关闭或 ch 中没有值，b 则为 false</span></span><br></pre></td></tr></table></figure>
<h2 id="无缓存-channel"><a href="#无缓存-channel" class="headerlink" title="无缓存 channel"></a>无缓存 channel</h2><ol>
<li>无缓存 channel 的读写操作，都是阻塞的，也就是写入结束就是读取结束，如果一直没有读取，则写入永远是阻塞的，读取也是一样没有读取到数据之前，永远阻塞</li>
<li>close(chan) 关闭 channel 后，channel 是只读的，不能再写入</li>
<li>向 channel 写入数据的代码应该在 goroutine 的最后一行，不会因为阻塞影响 goroutine 内其他操作</li>
<li>无缓存 channel 是线程安全的，多个 goroutine 同时操作，同一个时间只能有一个 goroutine 进行读写操作</li>
</ol>
<h3 id="无缓存-channel-特性"><a href="#无缓存-channel-特性" class="headerlink" title="无缓存 channel 特性"></a>无缓存 channel 特性</h3><ul>
<li>下面例子是主协程和子协程之间通过无缓存 channel 通信，由于无缓存 channel 同一个时间只能有一个 goroutine 进行读写操作，所以是线程安全的</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := <span class="keyword">string</span>(<span class="number">97</span>)</span><br><span class="line">	ch1 &lt;- data</span><br><span class="line">	fmt.Println(<span class="string">"发出了数据"</span>, data)                              <span class="comment">// 向无缓存 channel 写入数据是阻塞的，也就是没有人接收就永远阻塞，所以这个语句永远不被执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> writer()</span><br><span class="line">	<span class="comment">// data := &lt;-ch1                                           // 打开注释，从 channel 取出数据时，writer 函数就会继续向下执行</span></span><br><span class="line">	<span class="comment">// fmt.Println("收到了数据", data)</span></span><br><span class="line">	time.Sleep(<span class="number">2e9</span>)                                            <span class="comment">// 在这里永远等不到 writer 协程执行完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">发出了数据 a</span><br><span class="line">收到了数据 a</span><br></pre></td></tr></table></figure>
<h3 id="多个协程使用无缓存-channel"><a href="#多个协程使用无缓存-channel" class="headerlink" title="多个协程使用无缓存 channel"></a>多个协程使用无缓存 channel</h3><ol>
<li>下面例子是两个协程之间的通信</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	ch2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">97</span>; i &lt;= <span class="number">97</span>+<span class="number">25</span>; i++ &#123;</span><br><span class="line">		ch1 &lt;- <span class="keyword">string</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line">	ch2 &lt;- <span class="string">"数据发送完毕"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> ch1 &#123;                                      <span class="comment">// range 在取得数据的时候是永远阻塞的</span></span><br><span class="line">		fmt.Println(<span class="string">"接收到的数据为"</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">    fmt.Println(<span class="string">"取出数据完毕"</span>)                                 <span class="comment">// 这一句是永远不能执行的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> fn1()</span><br><span class="line">	<span class="keyword">go</span> fn2()</span><br><span class="line">	result1 := &lt;-ch2</span><br><span class="line">	fmt.Println(result1)</span><br><span class="line">	fmt.Println(<span class="string">"程序执行完毕"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">接收到的数据为 a</span><br><span class="line">接收到的数据为 b</span><br><span class="line">接收到的数据为 c</span><br><span class="line">接收到的数据为 d</span><br><span class="line">接收到的数据为 e</span><br><span class="line">接收到的数据为 f</span><br><span class="line">接收到的数据为 g</span><br><span class="line">接收到的数据为 h</span><br><span class="line">接收到的数据为 i</span><br><span class="line">接收到的数据为 j</span><br><span class="line">接收到的数据为 k</span><br><span class="line">接收到的数据为 l</span><br><span class="line">接收到的数据为 m</span><br><span class="line">接收到的数据为 n</span><br><span class="line">接收到的数据为 o</span><br><span class="line">接收到的数据为 p</span><br><span class="line">接收到的数据为 q</span><br><span class="line">接收到的数据为 r</span><br><span class="line">接收到的数据为 s</span><br><span class="line">接收到的数据为 t</span><br><span class="line">接收到的数据为 u</span><br><span class="line">接收到的数据为 v</span><br><span class="line">接收到的数据为 w</span><br><span class="line">接收到的数据为 x</span><br><span class="line">接收到的数据为 y</span><br><span class="line">接收到的数据为 z</span><br><span class="line">数据发送完毕</span><br><span class="line">程序执行完毕</span><br></pre></td></tr></table></figure>
<ul>
<li>WaitGroup</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    t0 := time.Now()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">97</span>; i&lt;= <span class="number">97</span>+<span class="number">25</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">            ch1 &lt;- <span class="keyword">string</span>(i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> ch1 &#123;</span><br><span class="line">            count++</span><br><span class="line">            fmt.Println(<span class="string">"接收到的数据为"</span>, n)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"取出数据完毕"</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    wg.Wait()</span><br><span class="line">	t1 := time.Since(t0)</span><br><span class="line">	fmt.Println(<span class="string">"用时"</span>, t1, <span class="string">"总计收到"</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="死锁状态"><a href="#死锁状态" class="headerlink" title="死锁状态"></a>死锁状态</h2><p>在主 goroutine 向无缓存 channel 添加内容或在主 goroutine 中向 channel 添加内容且添加的个数已经大于 channel 缓存个数就会产生死锁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure>
<p>死锁：在程序中多个进程，由于相互竞争资源而产生的阻塞状态，这种状态一直保持下去，造成程序阻塞，称为死锁。</p>
<p>在 Go 语言中使用无缓存 channel 时一定要注意，主协程中有 ch &lt;-1 ，无缓存 channel 无论添加还是取出数据都会一直阻塞 goroutine，当前程序无其他代码，主 goroutine 会一直被阻塞下去，此时就是死锁状态。</p>
<ol>
<li>死锁的产生一般是在主协程</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">	ch1 &lt;- <span class="string">"死锁示例"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>子协程的阻塞不会对程序造成死锁</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writer</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := <span class="keyword">string</span>(<span class="number">97</span>)</span><br><span class="line">	ch1 &lt;- data</span><br><span class="line">	fmt.Println(<span class="string">"发出了数据"</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> writer()</span><br><span class="line">	time.Sleep(<span class="number">2e9</span>)</span><br><span class="line">	fmt.Println(<span class="string">"程序执行结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有缓存-channel"><a href="#有缓存-channel" class="headerlink" title="有缓存 channel"></a>有缓存 channel</h2><ol>
<li>创建一个有缓存 channel</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>)    <span class="comment">// 缓存大小为 3，也就是说向 channel 消息数量不大于 3 不会阻塞</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 &lt;- <span class="number">1</span></span><br><span class="line">	ch1 &lt;- <span class="number">2</span></span><br><span class="line">	ch1 &lt;- <span class="number">3</span></span><br><span class="line">	<span class="comment">// ch1 &lt;- 4                // 由于超过了 channel 的容量主协程阻塞，产生死锁</span></span><br><span class="line">	fmt.Println(<span class="string">"程序执行结束"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="select-事件"><a href="#select-事件" class="headerlink" title="select 事件"></a>select 事件</h1><p>Go 语言中 select 和 switch 结构特别像，但是 select 中 case 条件只能是 i/o</p>
<h2 id="select-的语法"><a href="#select-的语法" class="headerlink" title="select 的语法"></a>select 的语法</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> condition: </span><br><span class="line">    	code...</span><br><span class="line">    <span class="keyword">case</span> condition:</span><br><span class="line">    	code...</span><br><span class="line">    <span class="keyword">case</span> condition:</span><br><span class="line">    	code...</span><br><span class="line">    <span class="keyword">default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>每个 case 必须是一个 IO 操作</li>
<li><p>哪个 case 可以执行就执行哪个，当多个 case 都可以执行，则随机选择一个</p>
</li>
<li><p>所有 case 都不能执行时，执行 default</p>
</li>
<li>所有 case 都不能执行，且没有 deafult 程序将会阻塞</li>
</ol>
<h2 id="select-代码示例"><a href="#select-代码示例" class="headerlink" title="select 代码示例"></a>select 代码示例</h2><ol>
<li>select 基本的使用方法</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">	ch2 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 &lt;- <span class="number">1</span></span><br><span class="line">	ch2 &lt;- <span class="number">2</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> value := &lt;-ch1:</span><br><span class="line">		fmt.Println(value)</span><br><span class="line">	<span class="keyword">case</span> value := &lt;-ch2:</span><br><span class="line">		fmt.Println(value)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>for 循环中使用</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			ch1 &lt;- j</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// for i := 0; i &lt; 10; i++ &#123;</span></span><br><span class="line">	<span class="keyword">for</span> &#123;                             <span class="comment">// 不断的从 ch1 中接收数据</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> a := &lt;-ch1:</span><br><span class="line">			fmt.Println(a)</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/43/">43</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Jin Heng">
            
              <p class="site-author-name" itemprop="name">Jin Heng</p>
              <p class="site-description motion-element" itemprop="description">越努力越幸运</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yangjinheng" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:jinhengyang@foxmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          
        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jin Heng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  













  





  

  

  

  
  

  

  

  

</body>
</html>
